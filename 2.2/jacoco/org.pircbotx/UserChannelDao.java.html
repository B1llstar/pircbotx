<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>UserChannelDao.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pircbotx</a> &gt; <a href="index.source.html" class="el_package">org.pircbotx</a> &gt; <span class="el_source">UserChannelDao.java</span></div><h1>UserChannelDao.java</h1><pre class="source lang-java linenums">// Generated by delombok at Mon Apr 13 22:36:03 CEST 2020
/**
 * Copyright (C) 2010-2014 Leon Blakey &lt;lord.quackstar at gmail.com&gt;
 *
 * This file is part of PircBotX.
 *
 * PircBotX is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * PircBotX is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * PircBotX. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.pircbotx;

import static com.google.common.base.Preconditions.*;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Maps;
import java.io.Closeable;
import java.util.EnumMap;
import java.util.HashSet;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import lombok.NonNull;
import org.apache.commons.lang3.StringUtils;
import org.pircbotx.exception.DaoException;
import org.pircbotx.hooks.events.UserListEvent;
import org.pircbotx.snapshot.ChannelSnapshot;
import org.pircbotx.snapshot.UserChannelDaoSnapshot;
import org.pircbotx.snapshot.UserChannelMapSnapshot;
import org.pircbotx.snapshot.UserSnapshot;

/**
 * Model that creates and tracks Users and Channel and maintains relationships.
 * This includes channel users, channel op/voice/etc users, private messages,
 * etc
 * &lt;p&gt;
 * All methods will throw a {@link NullPointerException} when any argument is
 * null
 *
 * @see User
 * @see Channel
 * @author Leon Blakey
 */
public class UserChannelDao&lt;U extends User, C extends Channel&gt; implements Closeable {
	protected final PircBotX bot;
	protected final Configuration.BotFactory botFactory;
	protected final Locale locale;
<span class="fc" id="L56">	protected final Object accessLock = new Object();</span>
	protected final UserChannelMap&lt;U, C&gt; mainMap;
	protected final EnumMap&lt;UserLevel, UserChannelMap&lt;U, C&gt;&gt; levelsMap;
	protected final Map&lt;String, U&gt; userNickMap;
	protected final Map&lt;String, C&gt; channelNameMap;
	protected final Map&lt;String, U&gt; privateUsers;

<span class="fc" id="L63">	protected UserChannelDao(PircBotX bot, Configuration.BotFactory botFactory) {</span>
<span class="fc" id="L64">		this.bot = bot;</span>
<span class="fc" id="L65">		this.botFactory = botFactory;</span>
<span class="fc" id="L66">		this.locale = bot.getConfiguration().getLocale();</span>
<span class="fc" id="L67">		this.mainMap = new UserChannelMap&lt;U, C&gt;();</span>
<span class="fc" id="L68">		this.userNickMap = Maps.newHashMap();</span>
<span class="fc" id="L69">		this.channelNameMap = Maps.newHashMap();</span>
<span class="fc" id="L70">		this.privateUsers = Maps.newHashMap();</span>
		//Initialize levels map with a UserChannelMap for each level
<span class="fc" id="L72">		this.levelsMap = Maps.newEnumMap(UserLevel.class);</span>
<span class="fc bfc" id="L73" title="All 2 branches covered.">		for (UserLevel level : UserLevel.values()) levelsMap.put(level, new UserChannelMap&lt;U, C&gt;());</span>
<span class="fc" id="L74">	}</span>

	/**
	 * Lookup user by nick, throwing a {@link DaoException} if not found
	 *
	 * @param nick The nick of the user
	 * @return Known active {@link User}
	 * @throws DaoException If user does not exist, exception will contain
	 * {@link org.pircbotx.exception.DaoException.Reason#UNKNOWN_USER} and the
	 * nick that doesn't exist
	 */
	public U getUser(@NonNull String nick) throws DaoException {
<span class="fc" id="L86">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">			if (nick == null) {</span>
<span class="nc" id="L88">				throw new java.lang.NullPointerException(&quot;nick&quot;);</span>
			}
<span class="fc" id="L90">			checkArgument(StringUtils.isNotBlank(nick), &quot;Cannot get a blank user&quot;);</span>
<span class="fc" id="L91">			U user = userNickMap.get(nick.toLowerCase(locale));</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">			if (user != null) return user;</span>
			//Does not exist
<span class="fc" id="L94">			throw new DaoException(DaoException.Reason.UNKNOWN_USER, nick);</span>
<span class="fc" id="L95">		}</span>
	}

	/**
	 * Lookup user by UserHostmask, throwing a {@link DaoException} if not found
	 *
	 * @param userHostmask The hostmask of the user
	 * @return Known active {@link User}
	 * @throws DaoException If user does not exist, exception will contain
	 * {@link org.pircbotx.exception.DaoException.Reason#UNKNOWN_USER_HOSTMASK},
	 * hostmask, and wrapped exception with nick
	 */
	public U getUser(@NonNull UserHostmask userHostmask) {
<span class="fc" id="L108">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">			if (userHostmask == null) {</span>
<span class="nc" id="L110">				throw new java.lang.NullPointerException(&quot;userHostmask&quot;);</span>
			}
			try {
				//Rarely we don't get the full hostmask
				//eg, the server setting your usermode when you connect to the server
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">				if (userHostmask.getNick() == null) return getUser(userHostmask.getHostmask());</span>
<span class="fc" id="L116">				return getUser(userHostmask.getNick());</span>
<span class="nc" id="L117">			} catch (Exception e) {</span>
				//Does not exist, wrap with detail about hostmask
<span class="nc" id="L119">				throw new DaoException(DaoException.Reason.UNKNOWN_USER_HOSTMASK, userHostmask.toString(), e);</span>
			}
<span class="nc" id="L121">		}</span>
	}

	/**
	 * Create a user from a hostmask, internally called when a valid, real user
	 * contacts us
	 *
	 * @param userHostmask The hostmask of the user
	 * @return Active {@link User} that was created
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public U createUser(@NonNull UserHostmask userHostmask) {
<span class="fc" id="L133">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">			if (userHostmask == null) {</span>
<span class="nc" id="L135">				throw new java.lang.NullPointerException(&quot;userHostmask&quot;);</span>
			}
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">			if (containsUser(userHostmask)) throw new RuntimeException(&quot;Cannot create a user from hostmask that already exists: &quot; + userHostmask);</span>
<span class="fc" id="L138">			U user = (U)botFactory.createUser(userHostmask);</span>
<span class="fc" id="L139">			userNickMap.put(userHostmask.getNick().toLowerCase(locale), user);</span>
<span class="fc" id="L140">			return user;</span>
<span class="nc" id="L141">		}</span>
	}

	/**
	 * @deprecated Renamed {@link #containsUser(java.lang.String) } to match
	 * Java Collections API
	 * @see #containsUser(java.lang.String)
	 */
	@Deprecated
	public boolean userExists(@NonNull String nick) {
<span class="fc" id="L151">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">			if (nick == null) {</span>
<span class="nc" id="L153">				throw new java.lang.NullPointerException(&quot;nick&quot;);</span>
			}
<span class="fc" id="L155">			return containsUser(nick);</span>
<span class="nc" id="L156">		}</span>
	}

	/**
	 * Check if user exists by nick
	 *
	 * @param nick Nick of user
	 * @return True if user exists
	 */
	public boolean containsUser(@NonNull String nick) {
<span class="fc" id="L166">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">			if (nick == null) {</span>
<span class="nc" id="L168">				throw new java.lang.NullPointerException(&quot;nick&quot;);</span>
			}
<span class="fc" id="L170">			String nickLowercase = nick.toLowerCase(locale);</span>
<span class="pc bpc" id="L171" title="1 of 4 branches missed.">			return userNickMap.containsKey(nickLowercase) || privateUsers.containsKey(nickLowercase);</span>
<span class="nc" id="L172">		}</span>
	}

	/**
	 * Check if user exists by hostmask
	 *
	 * @param hostmask Hostmask of user
	 * @return True if user exists
	 */
	public boolean containsUser(@NonNull UserHostmask hostmask) {
<span class="fc" id="L182">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">			if (hostmask == null) {</span>
<span class="nc" id="L184">				throw new java.lang.NullPointerException(&quot;hostmask&quot;);</span>
			}
<span class="fc" id="L186">			return containsUser(hostmask.getNick());</span>
<span class="nc" id="L187">		}</span>
	}

	/**
	 * Get all currently known users, except from just joined channels where the
	 * WHO response hasn't finished (listen for {@link UserListEvent} instead)
	 *
	 * @return An immutable set of the currently known users
	 * @see UserListEvent
	 */
	public ImmutableSortedSet&lt;U&gt; getAllUsers() {
<span class="fc" id="L198">		synchronized (this.accessLock) {</span>
<span class="fc" id="L199">			return ImmutableSortedSet.copyOf(userNickMap.values());</span>
<span class="nc" id="L200">		}</span>
	}

	protected void addUserToChannel(@NonNull U user, @NonNull C channel) {
<span class="fc" id="L204">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">			if (user == null) {</span>
<span class="nc" id="L206">				throw new java.lang.NullPointerException(&quot;user&quot;);</span>
			}
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">			if (channel == null) {</span>
<span class="nc" id="L209">				throw new java.lang.NullPointerException(&quot;channel&quot;);</span>
			}
<span class="fc" id="L211">			mainMap.addUserToChannel(user, channel);</span>
<span class="pc" id="L212">		}</span>
<span class="fc" id="L213">	}</span>

	protected void addUserToPrivate(@NonNull U user) {
<span class="fc" id="L216">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">			if (user == null) {</span>
<span class="nc" id="L218">				throw new java.lang.NullPointerException(&quot;user&quot;);</span>
			}
<span class="fc" id="L220">			String nick = user.getNick().toLowerCase(locale);</span>
<span class="fc" id="L221">			privateUsers.put(nick, user);</span>
<span class="pc" id="L222">		}</span>
<span class="fc" id="L223">	}</span>

	protected void addUserToLevel(@NonNull UserLevel level, @NonNull U user, @NonNull C channel) {
<span class="fc" id="L226">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">			if (level == null) {</span>
<span class="nc" id="L228">				throw new java.lang.NullPointerException(&quot;level&quot;);</span>
			}
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">			if (user == null) {</span>
<span class="nc" id="L231">				throw new java.lang.NullPointerException(&quot;user&quot;);</span>
			}
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">			if (channel == null) {</span>
<span class="nc" id="L234">				throw new java.lang.NullPointerException(&quot;channel&quot;);</span>
			}
<span class="fc" id="L236">			levelsMap.get(level).addUserToChannel(user, channel);</span>
<span class="pc" id="L237">		}</span>
<span class="fc" id="L238">	}</span>

	protected void removeUserFromLevel(@NonNull UserLevel level, @NonNull U user, @NonNull C channel) {
<span class="fc" id="L241">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">			if (level == null) {</span>
<span class="nc" id="L243">				throw new java.lang.NullPointerException(&quot;level&quot;);</span>
			}
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">			if (user == null) {</span>
<span class="nc" id="L246">				throw new java.lang.NullPointerException(&quot;user&quot;);</span>
			}
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">			if (channel == null) {</span>
<span class="nc" id="L249">				throw new java.lang.NullPointerException(&quot;channel&quot;);</span>
			}
<span class="fc" id="L251">			levelsMap.get(level).removeUserFromChannel(user, channel);</span>
<span class="pc" id="L252">		}</span>
<span class="fc" id="L253">	}</span>

	/**
	 * Gets all currently known users in a channel who do not hold a UserLevel
	 * (op/voice/etc). A {@link UserListEvent} for the channel must of been
	 * dispatched before this method will return complete results
	 *
	 * @param channel Known channel
	 * @return An immutable sorted set of Users
	 */
	public ImmutableSortedSet&lt;U&gt; getNormalUsers(@NonNull C channel) {
<span class="nc" id="L264">		synchronized (this.accessLock) {</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">			if (channel == null) {</span>
<span class="nc" id="L266">				throw new java.lang.NullPointerException(&quot;channel&quot;);</span>
			}
<span class="nc" id="L268">			Set&lt;U&gt; remainingUsers = new HashSet&lt;U&gt;(mainMap.getUsers(channel));</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">			for (UserChannelMap&lt;U, C&gt; curLevelMap : levelsMap.values()) remainingUsers.removeAll(curLevelMap.getUsers(channel));</span>
<span class="nc" id="L270">			return ImmutableSortedSet.copyOf(remainingUsers);</span>
<span class="nc" id="L271">		}</span>
	}

	/**
	 * Gets all currently known users in a channel that hold the specified
	 * UserLevel. A {@link UserListEvent} for the channel must of been
	 * dispatched before this method will return complete results
	 *
	 * @param channel Known channel
	 * @param level Level users must hold
	 * @return An immutable sorted set of Users
	 */
	public ImmutableSortedSet&lt;U&gt; getUsers(@NonNull C channel, @NonNull UserLevel level) {
<span class="nc" id="L284">		synchronized (this.accessLock) {</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">			if (channel == null) {</span>
<span class="nc" id="L286">				throw new java.lang.NullPointerException(&quot;channel&quot;);</span>
			}
<span class="nc bnc" id="L288" title="All 2 branches missed.">			if (level == null) {</span>
<span class="nc" id="L289">				throw new java.lang.NullPointerException(&quot;level&quot;);</span>
			}
<span class="nc" id="L291">			return levelsMap.get(level).getUsers(channel);</span>
<span class="nc" id="L292">		}</span>
	}

	/**
	 * Gets all currently known levels (op/voice/etc) a user holds in the
	 * channel. A {@link UserListEvent} for the channel must of been dispatched
	 * before this method will return complete results
	 *
	 * @param channel Known channel
	 * @param user Known user
	 * @return An immutable sorted set of UserLevels
	 */
	public ImmutableSortedSet&lt;UserLevel&gt; getLevels(@NonNull C channel, @NonNull U user) {
<span class="nc" id="L305">		synchronized (this.accessLock) {</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">			if (channel == null) {</span>
<span class="nc" id="L307">				throw new java.lang.NullPointerException(&quot;channel&quot;);</span>
			}
<span class="nc bnc" id="L309" title="All 2 branches missed.">			if (user == null) {</span>
<span class="nc" id="L310">				throw new java.lang.NullPointerException(&quot;user&quot;);</span>
			}
<span class="nc" id="L312">			ImmutableSortedSet.Builder&lt;UserLevel&gt; builder = ImmutableSortedSet.naturalOrder();</span>
<span class="nc bnc" id="L313" title="All 4 branches missed.">			for (Map.Entry&lt;UserLevel, UserChannelMap&lt;U, C&gt;&gt; curEntry : levelsMap.entrySet()) if (curEntry.getValue().containsEntry(user, channel)) builder.add(curEntry.getKey());</span>
<span class="nc" id="L314">			return builder.build();</span>
<span class="nc" id="L315">		}</span>
	}

	/**
	 * Gets all currently known channels the user is a part of as a normal user.
	 * A {@link UserListEvent} for all channels must of been dispatched before
	 * this method will return complete results
	 *
	 * @param user Known user
	 * @return An immutable sorted set of Channels
	 */
	public ImmutableSortedSet&lt;C&gt; getNormalUserChannels(@NonNull U user) {
<span class="nc" id="L327">		synchronized (this.accessLock) {</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">			if (user == null) {</span>
<span class="nc" id="L329">				throw new java.lang.NullPointerException(&quot;user&quot;);</span>
			}
<span class="nc" id="L331">			Set&lt;C&gt; remainingChannels = new HashSet&lt;C&gt;(mainMap.getChannels(user));</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">			for (UserChannelMap&lt;U, C&gt; curLevelMap : levelsMap.values()) remainingChannels.removeAll(curLevelMap.getChannels(user));</span>
<span class="nc" id="L333">			return ImmutableSortedSet.copyOf(remainingChannels);</span>
<span class="nc" id="L334">		}</span>
	}

	/**
	 * Gets all currently known channels the user is a part of with the
	 * specified level. A {@link UserListEvent} for all channels must of been
	 * dispatched before this method will return complete results
	 *
	 * @param user Known user
	 * @return An immutable sorted set of Channels
	 */
	public ImmutableSortedSet&lt;C&gt; getChannels(@NonNull U user, @NonNull UserLevel level) {
<span class="fc" id="L346">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">			if (user == null) {</span>
<span class="nc" id="L348">				throw new java.lang.NullPointerException(&quot;user&quot;);</span>
			}
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">			if (level == null) {</span>
<span class="nc" id="L351">				throw new java.lang.NullPointerException(&quot;level&quot;);</span>
			}
<span class="fc" id="L353">			return levelsMap.get(level).getChannels(user);</span>
<span class="nc" id="L354">		}</span>
	}

	protected void removeUserFromChannel(@NonNull U user, @NonNull C channel) {
<span class="fc" id="L358">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">			if (user == null) {</span>
<span class="nc" id="L360">				throw new java.lang.NullPointerException(&quot;user&quot;);</span>
			}
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">			if (channel == null) {</span>
<span class="nc" id="L363">				throw new java.lang.NullPointerException(&quot;channel&quot;);</span>
			}
<span class="fc" id="L365">			mainMap.removeUserFromChannel(user, channel);</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">			for (UserChannelMap&lt;U, C&gt; curLevelMap : levelsMap.values()) curLevelMap.removeUserFromChannel(user, channel);</span>
<span class="pc bpc" id="L367" title="2 of 4 branches missed.">			if (!privateUsers.values().contains(user) &amp;&amp; !mainMap.containsUser(user)) </span>
			//Completely remove user
<span class="fc" id="L369">			userNickMap.remove(user.getNick().toLowerCase(locale));</span>
<span class="pc" id="L370">		}</span>
<span class="fc" id="L371">	}</span>

	protected void removeUser(@NonNull U user) {
<span class="fc" id="L374">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">			if (user == null) {</span>
<span class="nc" id="L376">				throw new java.lang.NullPointerException(&quot;user&quot;);</span>
			}
<span class="fc" id="L378">			mainMap.removeUser(user);</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">			for (UserChannelMap&lt;U, C&gt; curLevelMap : levelsMap.values()) curLevelMap.removeUser(user);</span>
			//Remove remaining locations
<span class="fc" id="L381">			userNickMap.remove(user.getNick().toLowerCase(locale));</span>
<span class="fc" id="L382">			privateUsers.remove(user.getNick().toLowerCase(locale));</span>
<span class="pc" id="L383">		}</span>
<span class="fc" id="L384">	}</span>

	protected boolean levelContainsUser(@NonNull UserLevel level, @NonNull C channel, @NonNull U user) {
<span class="fc" id="L387">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">			if (level == null) {</span>
<span class="nc" id="L389">				throw new java.lang.NullPointerException(&quot;level&quot;);</span>
			}
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">			if (channel == null) {</span>
<span class="nc" id="L392">				throw new java.lang.NullPointerException(&quot;channel&quot;);</span>
			}
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">			if (user == null) {</span>
<span class="nc" id="L395">				throw new java.lang.NullPointerException(&quot;user&quot;);</span>
			}
<span class="fc" id="L397">			return levelsMap.get(level).containsEntry(user, channel);</span>
<span class="nc" id="L398">		}</span>
	}

	protected void renameUser(@NonNull U user, @NonNull String newNick) {
<span class="fc" id="L402">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">			if (user == null) {</span>
<span class="nc" id="L404">				throw new java.lang.NullPointerException(&quot;user&quot;);</span>
			}
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">			if (newNick == null) {</span>
<span class="nc" id="L407">				throw new java.lang.NullPointerException(&quot;newNick&quot;);</span>
			}
<span class="fc" id="L409">			String oldNick = user.getNick();</span>
<span class="fc" id="L410">			user.setNick(newNick);</span>
<span class="fc" id="L411">			userNickMap.remove(oldNick.toLowerCase(locale));</span>
<span class="fc" id="L412">			userNickMap.put(newNick.toLowerCase(locale), user);</span>
<span class="pc" id="L413">		}</span>
<span class="fc" id="L414">	}</span>

	/**
	 * Lookup channel by name, throwing a {@link DaoException} if not found
	 *
	 * @param name Name of channel (eg #pircbotx)
	 * @return A known channel
	 */
	public C getChannel(@NonNull String name) throws DaoException {
<span class="fc" id="L423">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">			if (name == null) {</span>
<span class="nc" id="L425">				throw new java.lang.NullPointerException(&quot;name&quot;);</span>
			}
<span class="fc" id="L427">			checkArgument(StringUtils.isNotBlank(name), &quot;Cannot get a blank channel&quot;);</span>
<span class="fc" id="L428">			C chan = channelNameMap.get(name.toLowerCase(locale));</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">			if (chan != null) return chan;</span>
			//This could potentially be a mode message, strip off prefixes till we get a channel
<span class="fc" id="L431">			String modePrefixes = bot.getConfiguration().getUserLevelPrefixes();</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">			if (modePrefixes.contains(Character.toString(name.charAt(0)))) {</span>
<span class="fc" id="L433">				String nameTrimmed = name.toLowerCase(locale);</span>
				do {
<span class="fc" id="L435">					nameTrimmed = nameTrimmed.substring(1);</span>
<span class="fc" id="L436">					chan = channelNameMap.get(nameTrimmed);</span>
<span class="pc bpc" id="L437" title="1 of 2 branches missed.">					if (chan != null) return chan;</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">				}				 while (modePrefixes.contains(Character.toString(nameTrimmed.charAt(0))));</span>
			}
			//Channel does not exist
<span class="fc" id="L441">			throw new DaoException(DaoException.Reason.UNKNOWN_CHANNEL, name);</span>
<span class="fc" id="L442">		}</span>
	}

	/**
	 * Creates a known channel, internally called when we join a channel
	 *
	 * @param name
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public C createChannel(@NonNull String name) {
<span class="fc" id="L452">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">			if (name == null) {</span>
<span class="nc" id="L454">				throw new java.lang.NullPointerException(&quot;name&quot;);</span>
			}
<span class="fc" id="L456">			C chan = (C)botFactory.createChannel(bot, name);</span>
<span class="fc" id="L457">			channelNameMap.put(name.toLowerCase(locale), chan);</span>
<span class="fc" id="L458">			return chan;</span>
<span class="nc" id="L459">		}</span>
	}

	/**
	 * @deprecated Renamed {@link #containsChannel(java.lang.String) } to match
	 * the Java Collections API
	 * @see #containsChannel(java.lang.String)
	 */
	@Deprecated
	public boolean channelExists(@NonNull String name) {
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">		if (name == null) {</span>
<span class="nc" id="L470">			throw new java.lang.NullPointerException(&quot;name&quot;);</span>
		}
<span class="fc" id="L472">		return containsChannel(name);</span>
	}

	/**
	 * Check if we are currently in the given channel
	 *
	 * @param name Channel name (eg #pircbotx)
	 * @return True if we are still connected to the channel
	 */
	public boolean containsChannel(@NonNull String name) {
<span class="fc" id="L482">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">			if (name == null) {</span>
<span class="nc" id="L484">				throw new java.lang.NullPointerException(&quot;name&quot;);</span>
			}
<span class="fc bfc" id="L486" title="All 2 branches covered.">			if (channelNameMap.containsKey(name.toLowerCase(locale))) return true;</span>
			//This could potentially be a mode message, strip off prefixes till we get a channel
<span class="fc" id="L488">			String modePrefixes = bot.getConfiguration().getUserLevelPrefixes();</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">			if (modePrefixes.contains(Character.toString(name.charAt(0)))) {</span>
<span class="fc" id="L490">				String nameTrimmed = name.toLowerCase(locale);</span>
				do {
<span class="fc" id="L492">					nameTrimmed = nameTrimmed.substring(1);</span>
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">					if (channelNameMap.containsKey(nameTrimmed)) return true;</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">				}				 while (modePrefixes.contains(Character.toString(nameTrimmed.charAt(0))));</span>
			}
			//Nope, doesn't exist
<span class="fc" id="L497">			return false;</span>
<span class="nc" id="L498">		}</span>
	}

	/**
	 * Get all currently known users in a channel
	 *
	 * @param channel Known channel
	 * @return An immutable set of users
	 */
	public ImmutableSortedSet&lt;U&gt; getUsers(@NonNull C channel) {
<span class="fc" id="L508">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L509" title="1 of 2 branches missed.">			if (channel == null) {</span>
<span class="nc" id="L510">				throw new java.lang.NullPointerException(&quot;channel&quot;);</span>
			}
<span class="fc" id="L512">			return mainMap.getUsers(channel);</span>
<span class="nc" id="L513">		}</span>
	}

	/**
	 * Get all currently joined channels
	 *
	 * @return An immutable set of channels
	 */
	public ImmutableSortedSet&lt;C&gt; getAllChannels() {
<span class="fc" id="L522">		synchronized (this.accessLock) {</span>
<span class="fc" id="L523">			return ImmutableSortedSet.copyOf(channelNameMap.values());</span>
<span class="nc" id="L524">		}</span>
	}

	/**
	 * Get &lt;i&gt;channels we're joined to&lt;/i&gt; that the user is joined to as well
	 *
	 * @param user A known user
	 * @return An immutable set of channels
	 */
	public ImmutableSortedSet&lt;C&gt; getChannels(@NonNull U user) {
<span class="fc" id="L534">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">			if (user == null) {</span>
<span class="nc" id="L536">				throw new java.lang.NullPointerException(&quot;user&quot;);</span>
			}
<span class="fc" id="L538">			return mainMap.getChannels(user);</span>
<span class="nc" id="L539">		}</span>
	}

	protected void removeChannel(@NonNull C channel) {
<span class="nc" id="L543">		synchronized (this.accessLock) {</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">			if (channel == null) {</span>
<span class="nc" id="L545">				throw new java.lang.NullPointerException(&quot;channel&quot;);</span>
			}
<span class="nc" id="L547">			mainMap.removeChannel(channel);</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">			for (UserChannelMap&lt;U, C&gt; curLevelMap : levelsMap.values()) curLevelMap.removeChannel(channel);</span>
			//Remove remaining locations
<span class="nc" id="L550">			channelNameMap.remove(channel.getName());</span>
<span class="nc" id="L551">		}</span>
<span class="nc" id="L552">	}</span>

	/**
	 * Gets the bots own user object.
	 *
	 * @return The user object representing this bot
	 */
	public User getUserBot() {
<span class="nc" id="L560">		synchronized (this.accessLock) {</span>
<span class="nc" id="L561">			return getUser(bot.getNick());</span>
<span class="nc" id="L562">		}</span>
	}

	/**
	 * Clears all internal maps
	 */
	public void close() {
<span class="fc" id="L569">		synchronized (this.accessLock) {</span>
<span class="fc" id="L570">			mainMap.clear();</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">			for (UserChannelMap&lt;U, C&gt; curLevelMap : levelsMap.values()) curLevelMap.clear();</span>
<span class="fc" id="L572">			channelNameMap.clear();</span>
<span class="fc" id="L573">			privateUsers.clear();</span>
<span class="fc" id="L574">			userNickMap.clear();</span>
<span class="pc" id="L575">		}</span>
<span class="fc" id="L576">	}</span>

	/**
	 * Create an immutable snapshot (copy) of all of contained Users, Channels,
	 * and mappings, VERY EXPENSIVE.
	 *
	 * @return Copy of entire model
	 */
	public UserChannelDaoSnapshot createSnapshot() {
<span class="fc" id="L585">		synchronized (this.accessLock) {</span>
			//Create snapshots of all users and channels
<span class="fc" id="L587">			Map&lt;U, UserSnapshot&gt; userSnapshotMap = Maps.newHashMapWithExpectedSize(userNickMap.size());</span>
<span class="fc bfc" id="L588" title="All 2 branches covered.">			for (U curUser : userNickMap.values()) userSnapshotMap.put(curUser, curUser.createSnapshot());</span>
<span class="fc" id="L589">			Map&lt;C, ChannelSnapshot&gt; channelSnapshotMap = Maps.newHashMapWithExpectedSize(channelNameMap.size());</span>
<span class="fc bfc" id="L590" title="All 2 branches covered.">			for (C curChannel : channelNameMap.values()) channelSnapshotMap.put(curChannel, curChannel.createSnapshot());</span>
			//Make snapshots of the relationship maps using the above user and channel snapshots
<span class="fc" id="L592">			UserChannelMapSnapshot mainMapSnapshot = mainMap.createSnapshot(userSnapshotMap, channelSnapshotMap);</span>
<span class="fc" id="L593">			EnumMap&lt;UserLevel, UserChannelMap&lt;UserSnapshot, ChannelSnapshot&gt;&gt; levelsMapSnapshot = Maps.newEnumMap(UserLevel.class);</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">			for (Map.Entry&lt;UserLevel, UserChannelMap&lt;U, C&gt;&gt; curLevel : levelsMap.entrySet()) levelsMapSnapshot.put(curLevel.getKey(), curLevel.getValue().createSnapshot(userSnapshotMap, channelSnapshotMap));</span>
<span class="fc" id="L595">			ImmutableBiMap.Builder&lt;String, UserSnapshot&gt; userNickMapSnapshotBuilder = ImmutableBiMap.builder();</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">			for (Map.Entry&lt;String, U&gt; curNickEntry : userNickMap.entrySet()) userNickMapSnapshotBuilder.put(curNickEntry.getKey(), userSnapshotMap.get(curNickEntry.getValue()));</span>
<span class="fc" id="L597">			ImmutableBiMap.Builder&lt;String, ChannelSnapshot&gt; channelNameMapSnapshotBuilder = ImmutableBiMap.builder();</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">			for (Map.Entry&lt;String, C&gt; curName : channelNameMap.entrySet()) channelNameMapSnapshotBuilder.put(curName.getKey(), channelSnapshotMap.get(curName.getValue()));</span>
<span class="fc" id="L599">			ImmutableBiMap.Builder&lt;String, UserSnapshot&gt; privateUserSnapshotBuilder = ImmutableBiMap.builder();</span>
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">			for (Map.Entry&lt;String, U&gt; curNickEntry : privateUsers.entrySet()) privateUserSnapshotBuilder.put(curNickEntry.getKey(), userSnapshotMap.get(curNickEntry.getValue()));</span>
			//Finally can create the snapshot object
<span class="fc" id="L602">			UserChannelDaoSnapshot daoSnapshot = new UserChannelDaoSnapshot(bot, locale, mainMapSnapshot, levelsMapSnapshot, userNickMapSnapshotBuilder.build(), channelNameMapSnapshotBuilder.build(), privateUserSnapshotBuilder.build());</span>
			//Tell UserSnapshots and ChannelSnapshots what the new backing dao is
<span class="fc bfc" id="L604" title="All 2 branches covered.">			for (UserSnapshot curUserSnapshot : userSnapshotMap.values()) curUserSnapshot.setDao(daoSnapshot);</span>
<span class="fc bfc" id="L605" title="All 2 branches covered.">			for (ChannelSnapshot curChannelSnapshot : channelSnapshotMap.values()) curChannelSnapshot.setDao(daoSnapshot);</span>
			//Finally
<span class="fc" id="L607">			return daoSnapshot;</span>
<span class="nc" id="L608">		}</span>
	}

	@java.beans.ConstructorProperties({&quot;bot&quot;, &quot;botFactory&quot;, &quot;locale&quot;, &quot;mainMap&quot;, &quot;levelsMap&quot;, &quot;userNickMap&quot;, &quot;channelNameMap&quot;, &quot;privateUsers&quot;})
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
<span class="fc" id="L614">	protected UserChannelDao(final PircBotX bot, final Configuration.BotFactory botFactory, final Locale locale, final UserChannelMap&lt;U, C&gt; mainMap, final EnumMap&lt;UserLevel, UserChannelMap&lt;U, C&gt;&gt; levelsMap, final Map&lt;String, U&gt; userNickMap, final Map&lt;String, C&gt; channelNameMap, final Map&lt;String, U&gt; privateUsers) {</span>
<span class="fc" id="L615">		this.bot = bot;</span>
<span class="fc" id="L616">		this.botFactory = botFactory;</span>
<span class="fc" id="L617">		this.locale = locale;</span>
<span class="fc" id="L618">		this.mainMap = mainMap;</span>
<span class="fc" id="L619">		this.levelsMap = levelsMap;</span>
<span class="fc" id="L620">		this.userNickMap = userNickMap;</span>
<span class="fc" id="L621">		this.channelNameMap = channelNameMap;</span>
<span class="fc" id="L622">		this.privateUsers = privateUsers;</span>
<span class="fc" id="L623">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>