<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Channel.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pircbotx</a> &gt; <a href="index.source.html" class="el_package">org.pircbotx</a> &gt; <span class="el_source">Channel.java</span></div><h1>Channel.java</h1><pre class="source lang-java linenums">// Generated by delombok at Mon Apr 13 22:36:03 CEST 2020
/**
 * Copyright (C) 2010-2014 Leon Blakey &lt;lord.quackstar at gmail.com&gt;
 *
 * This file is part of PircBotX.
 *
 * PircBotX is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * PircBotX is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * PircBotX. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.pircbotx;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterators;
import com.google.common.collect.PeekingIterator;
import java.util.UUID;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.concurrent.AtomicSafeInitializer;
import org.apache.commons.lang3.concurrent.ConcurrentException;
import org.pircbotx.hooks.managers.ThreadedListenerManager;
import org.pircbotx.output.OutputChannel;
import org.pircbotx.snapshot.ChannelSnapshot;

/**
 * Represents a Channel that we're joined to.
 *
 * @author Leon Blakey
 */
public class Channel implements Comparable&lt;Channel&gt; {
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
<span class="fc" id="L43">	private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(Channel.class);</span>
	
	/**
	 * The name of the channel. Will never change
	 */
	protected final String name;
	
	/**
	 * Unique UUID for this channel &lt;i&gt;instance&lt;/i&gt;
	 */
	protected final UUID channelId;
	
	/**
	 * The bot that this channel came from
	 */
	protected final PircBotX bot;
	//Output is lazily created since it might not ever be used
<span class="fc" id="L60">	protected final AtomicSafeInitializer&lt;OutputChannel&gt; output = new AtomicSafeInitializer&lt;OutputChannel&gt;(){</span>
		
		
		@Override
		protected OutputChannel initialize() {
<span class="fc" id="L65">			return bot.getConfiguration().getBotFactory().createOutputChannel(bot, Channel.this);</span>
		}
	};
<span class="fc" id="L68">	protected String mode = &quot;&quot;;</span>
	
	/**
	 * The current channel topic
	 */
<span class="fc" id="L73">	protected String topic = &quot;&quot;;</span>
	
	/**
	 * Timestamp of when the topic was created. Defaults to 0
	 */
	protected long topicTimestamp;
	
	/**
	 * Timestamp of when channel was created. Defaults to 0
	 */
	protected long createTimestamp;
	
	/**
	 * The user who set the topic. Default is blank
	 */
	protected UserHostmask topicSetter;
	
	/**
	 * Moderated (+m) status
	 */
<span class="fc" id="L93">	protected boolean moderated = false;</span>
	
	/**
	 * No external messages (+n) status
	 */
<span class="fc" id="L98">	protected boolean noExternalMessages = false;</span>
	
	/**
	 * Invite only (+i) status
	 */
<span class="fc" id="L103">	protected boolean inviteOnly = false;</span>
	
	/**
	 * Secret (+s) status
	 */
<span class="fc" id="L108">	protected boolean secret = false;</span>
	
	/**
	 * Private (+p) status
	 */
<span class="fc" id="L113">	protected boolean channelPrivate = false;</span>
<span class="fc" id="L114">	protected boolean topicProtection = false;</span>
	
	/**
	 * Channel limit (+l #)
	 */
<span class="fc" id="L119">	protected int channelLimit = -1;</span>
	
	/**
	 * Channel key (+k)
	 */
<span class="fc" id="L124">	protected String channelKey = null;</span>
<span class="fc" id="L125">	protected CountDownLatch modeChangeLatch = null;</span>
<span class="fc" id="L126">	protected final Object modeChangeLock = new Object();</span>
	
<span class="fc" id="L128">	protected Channel(PircBotX bot, String name) {</span>
<span class="fc" id="L129">		this.bot = bot;</span>
<span class="fc" id="L130">		this.name = name;</span>
<span class="fc" id="L131">		this.channelId = UUID.randomUUID();</span>
<span class="fc" id="L132">	}</span>
	
	/**
	 * Used by ChannelSnapshot
	 *
	 * @param channel
	 */
<span class="fc" id="L139">	protected Channel(Channel channel) {</span>
<span class="fc" id="L140">		this.bot = channel.bot;</span>
<span class="fc" id="L141">		this.name = channel.name;</span>
<span class="fc" id="L142">		this.channelId = channel.channelId;</span>
<span class="fc" id="L143">	}</span>
	
	protected UserChannelDao&lt;User, Channel&gt; getDao() {
<span class="fc" id="L146">		return bot.getUserChannelDao();</span>
	}
	
	/**
	 * Send a line to the channel.
	 *
	 * @return A {@link OutputChannel} for this channel
	 */
	public OutputChannel send() {
		try {
<span class="fc" id="L156">			return output.get();</span>
<span class="nc" id="L157">		} catch (ConcurrentException ex) {</span>
<span class="nc" id="L158">			throw new RuntimeException(&quot;Could not generate OutputChannel for &quot; + getName(), ex);</span>
		}
	}
	
	protected void parseMode(String rawMode) {
<span class="fc" id="L163">		synchronized (modeChangeLock) {</span>
<span class="pc bpc" id="L164" title="1 of 6 branches missed.">			if (rawMode.contains(&quot; &quot;) || (mode != null &amp;&amp; mode.contains(&quot; &quot;))) {</span>
				//Mode contains arguments which are impossible to parse.
				//Could be a ban command (we shouldn't use this), channel key (should, but where), etc
				//Need to ask server
<span class="fc bfc" id="L168" title="All 2 branches covered.">				if (mode == null) log.trace(&quot;Unknown args in channel {} mode \'{}\', waiting on server to respond with mode&quot;, name, rawMode); else {</span>
<span class="fc" id="L169">					log.trace(&quot;Unknown args in channel {} mode \'{}\', getting fresh mode&quot;, name, rawMode);</span>
<span class="fc" id="L170">					mode = null;</span>
<span class="fc" id="L171">					modeChangeLatch = new CountDownLatch(1);</span>
<span class="fc" id="L172">					send().getMode();</span>
				}
			} else {
				//Parse mode by switching between removing and adding by the existance of a + or - sign
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">				if (mode == null) {</span>
<span class="nc" id="L177">					log.error(&quot;Channel mode for {} was null - initializing to empty&quot;, this.name);</span>
<span class="nc" id="L178">					mode = &quot;&quot;;</span>
				}
<span class="fc" id="L180">				boolean adding = true;</span>
<span class="fc bfc" id="L181" title="All 8 branches covered.">				for (char curChar : rawMode.toCharArray()) if (curChar == '-') adding = false; else if (curChar == '+') adding = true; else if (adding) mode = mode + curChar; else mode = mode.replace(Character.toString(curChar), &quot;&quot;);</span>
			}
<span class="pc" id="L183">		}</span>
<span class="fc" id="L184">	}</span>
	
	/**
	 * Gets the channel mode. If mode is simple (no arguments), this will return
	 * immediately. If its not (mode with arguments, eg channel key), then asks
	 * the server for the correct mode, waiting until it gets a response
	 * &lt;p&gt;
	 * &lt;b&gt;WARNING:&lt;/b&gt; Because of the last checking, a threaded listener manager
	 * like {@link ThreadedListenerManager} is required. Using a single threaded
	 * listener manager like
	 * {@link org.pircbotx.hooks.managers.GenericListenerManager} will mean this
	 * method &lt;i&gt;never returns&lt;/i&gt;!
	 *
	 * @return A known good mode, either immediately or soon.
	 */
	public String getMode() {
<span class="fc" id="L200">		synchronized (modeChangeLock) {</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">			if (mode != null) return mode;</span>
<span class="nc" id="L202">		}</span>
<span class="nc" id="L203">		log.debug(&quot;Pausing channel {} getMode() until server responds with fresh mode&quot;, name);</span>
		//While unlikely, mode could be reset. Continuously try
<span class="nc" id="L205">		int counter = 0;</span>
		while (true) {
<span class="nc" id="L207">			log.trace(&quot;Attempt #{} to get mode for channel {}&quot;, counter++, name);</span>
			try {
				CountDownLatch modeWait;
<span class="nc" id="L210">				synchronized (modeChangeLock) {</span>
<span class="nc" id="L211">					modeWait = modeChangeLatch;</span>
<span class="nc" id="L212">				}</span>
<span class="nc" id="L213">				modeWait.await(250, TimeUnit.MILLISECONDS);//Don't wait forever</span>
<span class="nc" id="L214">			} catch (InterruptedException e) {</span>
<span class="nc" id="L215">				throw new RuntimeException(&quot;Waiting for mode response for channel &quot; + name + &quot; interrupted&quot;, e);</span>
<span class="nc" id="L216">			}</span>
<span class="nc" id="L217">			synchronized (modeChangeLock) {</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">				if (mode != null) {</span>
<span class="nc" id="L219">					log.debug(&quot;Exiting pause for channel {} getMode()&quot;, name);</span>
<span class="nc" id="L220">					return mode;</span>
				}
<span class="nc bnc" id="L222" title="All 2 branches missed.">				if (counter &gt;= 10) {</span>
					//if we have iterated more than 10x250ms (2½ seconds) then we set mode to empty
<span class="nc" id="L224">					log.warn(&quot;gave up on waithing for channel mode, channel {} getMode()&quot;, name);</span>
<span class="nc" id="L225">					mode = &quot;&quot;;</span>
<span class="nc" id="L226">					return mode;</span>
				}
<span class="nc" id="L228">			}</span>
		}
	}
	
	public boolean containsMode(char modeLetter) {
<span class="fc" id="L233">		final String mode = getMode();</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">		if (mode.isEmpty()) return false;</span>
<span class="fc" id="L235">		String modeLetters = StringUtils.split(mode, ' ')[0];</span>
<span class="fc" id="L236">		return StringUtils.contains(modeLetters, modeLetter);</span>
	}
	
	/**
	 * Check if the channel has topic protection (+t) set.
	 *
	 * @return True if +t
	 */
	public boolean hasTopicProtection() {
<span class="fc" id="L245">		return topicProtection;</span>
	}
	
	/**
	 * Get all levels the user holds in this channel.
	 *
	 * @param user The user to get the levels of
	 * @return An &lt;b&gt;immutable copy&lt;/b&gt; of the levels the user holds
	 */
	public ImmutableSortedSet&lt;UserLevel&gt; getUserLevels(User user) {
<span class="nc" id="L255">		return getDao().getLevels(this, user);</span>
	}
	
	/**
	 * Get all users that don't have any special status in this channel. This
	 * means that they aren't ops, have voice, superops, halops, or owners in
	 * this channel
	 *
	 * @return An &lt;b&gt;immutable copy&lt;/b&gt; of normal users
	 */
	public ImmutableSortedSet&lt;User&gt; getNormalUsers() {
<span class="nc" id="L266">		return getDao().getNormalUsers(this);</span>
	}
	
	/**
	 * Get all opped users in this channel.
	 *
	 * @return An &lt;b&gt;immutable copy&lt;/b&gt; of opped users
	 */
	public ImmutableSortedSet&lt;User&gt; getOps() {
<span class="nc" id="L275">		return getDao().getUsers(this, UserLevel.OP);</span>
	}
	
	/**
	 * Get all voiced users in this channel.
	 *
	 * @return An &lt;b&gt;immutable copy&lt;/b&gt; of voiced users
	 */
	public ImmutableSortedSet&lt;User&gt; getVoices() {
<span class="nc" id="L284">		return getDao().getUsers(this, UserLevel.VOICE);</span>
	}
	
	/**
	 * Get all users with Owner status in this channel.
	 *
	 * @return An &lt;b&gt;immutable copy&lt;/b&gt; of users with Owner status
	 */
	public ImmutableSortedSet&lt;User&gt; getOwners() {
<span class="nc" id="L293">		return getDao().getUsers(this, UserLevel.OWNER);</span>
	}
	
	/**
	 * Get all users with Half Operator status in this channel.
	 *
	 * @return An &lt;b&gt;immutable copy&lt;/b&gt; of users with Half Operator status
	 */
	public ImmutableSortedSet&lt;User&gt; getHalfOps() {
<span class="nc" id="L302">		return getDao().getUsers(this, UserLevel.HALFOP);</span>
	}
	
	/**
	 * Get all users with Super Operator status in this channel.
	 *
	 * @return An &lt;b&gt;immutable copy&lt;/b&gt; of users with Super Operator status
	 */
	public ImmutableSortedSet&lt;User&gt; getSuperOps() {
<span class="nc" id="L311">		return getDao().getUsers(this, UserLevel.SUPEROP);</span>
	}
	
	/**
	 * Sets the mode of the channel. If there is a getMode() waiting on this,
	 * fire it.
	 *
	 * @param mode
	 */
	protected void setMode(String mode, ImmutableList&lt;String&gt; modeParsed) {
<span class="fc" id="L321">		synchronized (modeChangeLock) {</span>
<span class="fc" id="L322">			this.mode = mode;</span>
			//Parse out mode
<span class="fc" id="L324">			PeekingIterator&lt;String&gt; params = Iterators.peekingIterator(modeParsed.iterator());</span>
			//Process modes letter by letter, grabbing paramaters as needed
<span class="fc" id="L326">			boolean adding = true;</span>
<span class="fc" id="L327">			String modeLetters = params.next();</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">			for (int i = 0; i &lt; modeLetters.length(); i++) {</span>
<span class="fc" id="L329">				char curModeChar = modeLetters.charAt(i);</span>
<span class="pc bpc" id="L330" title="1 of 4 branches missed.">				if (curModeChar == '+') adding = true; else if (curModeChar == '-') adding = false; else {</span>
<span class="fc" id="L331">					ChannelModeHandler modeHandler = bot.getConfiguration().getChannelModeHandlers().get(curModeChar);</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">					if (modeHandler != null) modeHandler.handleMode(bot, this, null, null, params, adding, false);</span>
				}
			}
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">			if (modeChangeLatch != null) modeChangeLatch.countDown();</span>
<span class="pc" id="L336">		}</span>
<span class="fc" id="L337">	}</span>
	
	/**
	 * Get all users in this channel. }
	 *
	 * @return An &lt;i&gt;Unmodifiable&lt;/i&gt; Set of users in this channel
	 */
	public ImmutableSortedSet&lt;User&gt; getUsers() {
<span class="fc" id="L345">		return getDao().getUsers(this);</span>
	}
	
	/**
	 * Get all the user's nicks in this channel
	 *
	 * @return An &lt;i&gt;Unmodifiable&lt;/i&gt; Set of user's nicks as String in this
	 * channel
	 */
	public ImmutableSortedSet&lt;String&gt; getUsersNicks() {
<span class="fc" id="L355">		ImmutableSortedSet.Builder&lt;String&gt; builder = ImmutableSortedSet.naturalOrder();</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">		for (User curUser : getDao().getUsers(this)) builder.add(curUser.getNick());</span>
<span class="fc" id="L357">		return builder.build();</span>
	}
	
	/**
	 * Get the user that set the topic. As the user may or may not be in the
	 * channel return as a string
	 *
	 * @return The user that set the topic in String format
	 */
	public UserHostmask getTopicSetter() {
<span class="fc" id="L367">		return topicSetter;</span>
	}
	
	/**
	 * Checks if the given user is an Operator in this channel
	 *
	 * @return True if the user is an Operator, false if not
	 */
	public boolean isOp(User user) {
<span class="fc" id="L376">		return getDao().levelContainsUser(UserLevel.OP, this, user);</span>
	}
	
	/**
	 * Checks if the given user has Voice in this channel.
	 *
	 * @return True if the user has Voice, false if not
	 */
	public boolean hasVoice(User user) {
<span class="fc" id="L385">		return getDao().levelContainsUser(UserLevel.VOICE, this, user);</span>
	}
	
	/**
	 * Checks if the given user is a Super Operator in this channel.
	 *
	 * @return True if the user is a Super Operator, false if not
	 */
	public boolean isSuperOp(User user) {
<span class="fc" id="L394">		return getDao().levelContainsUser(UserLevel.SUPEROP, this, user);</span>
	}
	
	/**
	 * Checks if the given user is an Owner in this channel.
	 *
	 * @return True if the user is an Owner, false if not
	 */
	public boolean isOwner(User user) {
<span class="fc" id="L403">		return getDao().levelContainsUser(UserLevel.OWNER, this, user);</span>
	}
	
	/**
	 * Checks if the given user is a Half Operator in this channel.
	 *
	 * @return True if the user is a Half Operator, false if not
	 */
	public boolean isHalfOp(User user) {
<span class="fc" id="L412">		return getDao().levelContainsUser(UserLevel.HALFOP, this, user);</span>
	}
	
	/**
	 * Create an immutable snapshot of this channel.
	 *
	 * @return Immutable Channel copy minus the DAO
	 */
	public ChannelSnapshot createSnapshot() {
<span class="fc" id="L421">		return new ChannelSnapshot(this, mode);</span>
	}
	
	/**
	 * Compare {@link #getName()} with {@link String#compareToIgnoreCase(java.lang.String)
	 * }. This is useful for sorting lists of Channel objects.
	 *
	 * @param other Other channel to compare to
	 * @return the result of calling compareToIgnoreCase on channel names.
	 */
	public int compareTo(Channel other) {
<span class="fc" id="L432">		return getName().compareToIgnoreCase(other.getName());</span>
	}
	
	@SuppressWarnings(&quot;unchecked&quot;)
	public &lt;T extends PircBotX&gt; T getBot() {
<span class="fc" id="L437">		return (T)bot;</span>
	}
	
	@java.lang.Override
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public java.lang.String toString() {
<span class="fc" id="L444">		return &quot;Channel(name=&quot; + this.name + &quot;, channelId=&quot; + this.channelId + &quot;, bot=&quot; + this.bot + &quot;, output=&quot; + this.output + &quot;, mode=&quot; + this.mode + &quot;, topic=&quot; + this.topic + &quot;, topicTimestamp=&quot; + this.topicTimestamp + &quot;, createTimestamp=&quot; + this.createTimestamp + &quot;, topicSetter=&quot; + this.topicSetter + &quot;, moderated=&quot; + this.moderated + &quot;, noExternalMessages=&quot; + this.noExternalMessages + &quot;, inviteOnly=&quot; + this.inviteOnly + &quot;, secret=&quot; + this.secret + &quot;, channelPrivate=&quot; + this.channelPrivate + &quot;, topicProtection=&quot; + this.topicProtection + &quot;, channelLimit=&quot; + this.channelLimit + &quot;, channelKey=&quot; + this.channelKey + &quot;, modeChangeLatch=&quot; + this.modeChangeLatch + &quot;, modeChangeLock=&quot; + this.modeChangeLock + &quot;)&quot;;</span>
	}
	
	@java.lang.Override
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public boolean equals(final java.lang.Object o) {
<span class="fc bfc" id="L451" title="All 2 branches covered.">		if (o == this) return true;</span>
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">		if (!(o instanceof Channel)) return false;</span>
<span class="fc" id="L453">		final Channel other = (Channel)o;</span>
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">		if (!other.canEqual((java.lang.Object)this)) return false;</span>
<span class="fc" id="L455">		final java.lang.Object this$name = this.getName();</span>
<span class="fc" id="L456">		final java.lang.Object other$name = other.getName();</span>
<span class="pc bpc" id="L457" title="4 of 6 branches missed.">		if (this$name == null ? other$name != null : !this$name.equals(other$name)) return false;</span>
<span class="fc" id="L458">		final java.lang.Object this$bot = this.getBot();</span>
<span class="fc" id="L459">		final java.lang.Object other$bot = other.getBot();</span>
<span class="pc bpc" id="L460" title="4 of 6 branches missed.">		if (this$bot == null ? other$bot != null : !this$bot.equals(other$bot)) return false;</span>
<span class="fc" id="L461">		return true;</span>
	}
	
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	protected boolean canEqual(final java.lang.Object other) {
<span class="fc" id="L467">		return other instanceof Channel;</span>
	}
	
	@java.lang.Override
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public int hashCode() {
<span class="fc" id="L474">		final int PRIME = 59;</span>
<span class="fc" id="L475">		int result = 1;</span>
<span class="fc" id="L476">		final java.lang.Object $name = this.getName();</span>
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">		result = result * PRIME + ($name == null ? 43 : $name.hashCode());</span>
<span class="fc" id="L478">		final java.lang.Object $bot = this.getBot();</span>
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">		result = result * PRIME + ($bot == null ? 43 : $bot.hashCode());</span>
<span class="fc" id="L480">		return result;</span>
	}
	
	/**
	 * The name of the channel. Will never change
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public String getName() {
<span class="fc" id="L489">		return this.name;</span>
	}
	
	/**
	 * Unique UUID for this channel &lt;i&gt;instance&lt;/i&gt;
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public UUID getChannelId() {
<span class="nc" id="L498">		return this.channelId;</span>
	}
	
	/**
	 * The current channel topic
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public String getTopic() {
<span class="fc" id="L507">		return this.topic;</span>
	}
	
	/**
	 * Timestamp of when the topic was created. Defaults to 0
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public long getTopicTimestamp() {
<span class="fc" id="L516">		return this.topicTimestamp;</span>
	}
	
	/**
	 * Timestamp of when channel was created. Defaults to 0
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public long getCreateTimestamp() {
<span class="fc" id="L525">		return this.createTimestamp;</span>
	}
	
	/**
	 * Moderated (+m) status
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public boolean isModerated() {
<span class="fc" id="L534">		return this.moderated;</span>
	}
	
	/**
	 * No external messages (+n) status
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public boolean isNoExternalMessages() {
<span class="fc" id="L543">		return this.noExternalMessages;</span>
	}
	
	/**
	 * Invite only (+i) status
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public boolean isInviteOnly() {
<span class="fc" id="L552">		return this.inviteOnly;</span>
	}
	
	/**
	 * Secret (+s) status
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public boolean isSecret() {
<span class="fc" id="L561">		return this.secret;</span>
	}
	
	/**
	 * Private (+p) status
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public boolean isChannelPrivate() {
<span class="fc" id="L570">		return this.channelPrivate;</span>
	}
	
	/**
	 * Channel limit (+l #)
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public int getChannelLimit() {
<span class="fc" id="L579">		return this.channelLimit;</span>
	}
	
	/**
	 * Channel key (+k)
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public String getChannelKey() {
<span class="fc" id="L588">		return this.channelKey;</span>
	}
	
	/**
	 * The current channel topic
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	protected void setTopic(final String topic) {
<span class="fc" id="L597">		this.topic = topic;</span>
<span class="fc" id="L598">	}</span>
	
	/**
	 * Timestamp of when the topic was created. Defaults to 0
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	protected void setTopicTimestamp(final long topicTimestamp) {
<span class="fc" id="L606">		this.topicTimestamp = topicTimestamp;</span>
<span class="fc" id="L607">	}</span>
	
	/**
	 * Timestamp of when channel was created. Defaults to 0
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	protected void setCreateTimestamp(final long createTimestamp) {
<span class="fc" id="L615">		this.createTimestamp = createTimestamp;</span>
<span class="fc" id="L616">	}</span>
	
	/**
	 * The user who set the topic. Default is blank
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	protected void setTopicSetter(final UserHostmask topicSetter) {
<span class="fc" id="L624">		this.topicSetter = topicSetter;</span>
<span class="fc" id="L625">	}</span>
	
	/**
	 * Moderated (+m) status
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	protected void setModerated(final boolean moderated) {
<span class="fc" id="L633">		this.moderated = moderated;</span>
<span class="fc" id="L634">	}</span>
	
	/**
	 * No external messages (+n) status
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	protected void setNoExternalMessages(final boolean noExternalMessages) {
<span class="fc" id="L642">		this.noExternalMessages = noExternalMessages;</span>
<span class="fc" id="L643">	}</span>
	
	/**
	 * Invite only (+i) status
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	protected void setInviteOnly(final boolean inviteOnly) {
<span class="fc" id="L651">		this.inviteOnly = inviteOnly;</span>
<span class="fc" id="L652">	}</span>
	
	/**
	 * Secret (+s) status
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	protected void setSecret(final boolean secret) {
<span class="fc" id="L660">		this.secret = secret;</span>
<span class="fc" id="L661">	}</span>
	
	/**
	 * Private (+p) status
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	protected void setChannelPrivate(final boolean channelPrivate) {
<span class="fc" id="L669">		this.channelPrivate = channelPrivate;</span>
<span class="fc" id="L670">	}</span>
	
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	protected void setTopicProtection(final boolean topicProtection) {
<span class="fc" id="L675">		this.topicProtection = topicProtection;</span>
<span class="fc" id="L676">	}</span>
	
	/**
	 * Channel limit (+l #)
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	protected void setChannelLimit(final int channelLimit) {
<span class="fc" id="L684">		this.channelLimit = channelLimit;</span>
<span class="fc" id="L685">	}</span>
	
	/**
	 * Channel key (+k)
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	protected void setChannelKey(final String channelKey) {
<span class="fc" id="L693">		this.channelKey = channelKey;</span>
<span class="fc" id="L694">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>