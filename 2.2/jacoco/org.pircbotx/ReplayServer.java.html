<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ReplayServer.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pircbotx</a> &gt; <a href="index.source.html" class="el_package">org.pircbotx</a> &gt; <span class="el_source">ReplayServer.java</span></div><h1>ReplayServer.java</h1><pre class="source lang-java linenums">// Generated by delombok at Mon Apr 13 22:36:03 CEST 2020
/**
 * Copyright (C) 2010-2014 Leon Blakey &lt;lord.quackstar at gmail.com&gt;
 *
 * This file is part of PircBotX.
 *
 * PircBotX is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * PircBotX is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * PircBotX. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.pircbotx;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.time.DurationFormatUtils;
import org.apache.commons.lang3.time.StopWatch;
import org.pircbotx.delay.StaticDelay;
import org.pircbotx.hooks.Event;
import org.pircbotx.hooks.ListenerAdapter;
import org.pircbotx.hooks.managers.GenericListenerManager;
import org.pircbotx.hooks.managers.ListenerManager;
import org.pircbotx.hooks.types.GenericMessageEvent;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;

/**
 * Helpful server for replaying a raw log to the bot.
 *
 * @author Leon Blakey
 */
<span class="nc" id="L46">public class ReplayServer {</span>
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
<span class="nc" id="L49">	private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(ReplayServer.class);</span>


	/**
	 * Redirect output to given queue and trick code to believe its connected to
	 * the IRC server
	 */
	protected static class ReplayPircBotX extends PircBotX {
		@java.lang.SuppressWarnings(&quot;all&quot;)
		@javax.annotation.Generated(&quot;lombok&quot;)
<span class="nc" id="L59">		private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(ReplayPircBotX.class);</span>
		protected final Queue&lt;String&gt; outputQueue;
<span class="nc" id="L61">		protected boolean closed = false;</span>

		public ReplayPircBotX(Configuration configuration, Queue&lt;String&gt; outputQueue) {
<span class="nc" id="L64">			super(configuration);</span>
<span class="nc" id="L65">			this.outputQueue = outputQueue;</span>
<span class="nc" id="L66">		}</span>

		@Override
		protected void sendRawLineToServer(String line) throws IOException {
<span class="nc" id="L70">			outputQueue.add(line);</span>
<span class="nc" id="L71">		}</span>

		@Override
		public boolean isConnected() {
<span class="nc" id="L75">			return true;</span>
		}

		@Override
		public void close() {
<span class="nc" id="L80">			closed = true;</span>
<span class="nc" id="L81">		}</span>

		@java.lang.SuppressWarnings(&quot;all&quot;)
		@javax.annotation.Generated(&quot;lombok&quot;)
		public boolean isClosed() {
<span class="nc" id="L86">			return this.closed;</span>
		}
	}

	/**
	 * Run all listeners in main thread and seperately queue events
	 */
	protected static class WrapperListenerManager implements ListenerManager {
		@java.lang.SuppressWarnings(&quot;all&quot;)
		@javax.annotation.Generated(&quot;lombok&quot;)
<span class="nc" id="L96">		private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(WrapperListenerManager.class);</span>

		private static interface ImplExclude {

			void onEvent(Event event);
		}
		protected final ListenerManager impl;
		protected final Queue&lt;Event&gt; eventQueue;

		@Override
		public void onEvent(Event event) {
<span class="nc" id="L107">			eventQueue.add(event);</span>
<span class="nc" id="L108">			impl.onEvent(event);</span>
<span class="nc" id="L109">		}</span>

		@java.beans.ConstructorProperties({&quot;impl&quot;, &quot;eventQueue&quot;})
		@java.lang.SuppressWarnings(&quot;all&quot;)
		@javax.annotation.Generated(&quot;lombok&quot;)
<span class="nc" id="L114">		public WrapperListenerManager(final ListenerManager impl, final Queue&lt;Event&gt; eventQueue) {</span>
<span class="nc" id="L115">			this.impl = impl;</span>
<span class="nc" id="L116">			this.eventQueue = eventQueue;</span>
<span class="nc" id="L117">		}</span>

		@java.lang.SuppressWarnings(&quot;all&quot;)
		@javax.annotation.Generated(&quot;lombok&quot;)
		public void addListener(final org.pircbotx.hooks.Listener listener) {
<span class="nc" id="L122">			this.impl.addListener(listener);</span>
<span class="nc" id="L123">		}</span>

		@java.lang.SuppressWarnings(&quot;all&quot;)
		@javax.annotation.Generated(&quot;lombok&quot;)
		public boolean removeListener(final org.pircbotx.hooks.Listener listener) {
<span class="nc" id="L128">			return this.impl.removeListener(listener);</span>
		}

		@java.lang.SuppressWarnings(&quot;all&quot;)
		@javax.annotation.Generated(&quot;lombok&quot;)
		public boolean listenerExists(final org.pircbotx.hooks.Listener listener) {
<span class="nc" id="L134">			return this.impl.listenerExists(listener);</span>
		}

		@java.lang.SuppressWarnings(&quot;all&quot;)
		@javax.annotation.Generated(&quot;lombok&quot;)
		public com.google.common.collect.ImmutableSet&lt;org.pircbotx.hooks.Listener&gt; getListeners() {
<span class="nc" id="L140">			return this.impl.getListeners();</span>
		}

		@java.lang.SuppressWarnings(&quot;all&quot;)
		@javax.annotation.Generated(&quot;lombok&quot;)
		public void shutdown(final org.pircbotx.PircBotX bot) {
<span class="nc" id="L146">			this.impl.shutdown(bot);</span>
<span class="nc" id="L147">		}</span>
	}

	public static void main(String[] args) throws Exception {
		try {
			//Make sure the user specified a file
<span class="nc bnc" id="L153" title="All 4 branches missed.">			if (args.length != 1 || args[0].trim().length() == 0) {</span>
<span class="nc" id="L154">				System.out.println(&quot;Usage: org.pircbotx.impl.ReplayServer [log]&quot;);</span>
<span class="nc" id="L155">				System.exit(1);</span>
			}
			//Start replaying file
<span class="nc" id="L158">			File file = new File(args[0].trim());</span>
<span class="nc" id="L159">			replayFile(file);</span>
<span class="nc" id="L160">		} catch (Exception t) {</span>
<span class="nc" id="L161">			log.debug(&quot;Caught exception in main, closing&quot;, t);</span>
<span class="nc" id="L162">			System.exit(3);</span>
<span class="nc" id="L163">		}</span>
<span class="nc" id="L164">	}</span>

<span class="nc" id="L166">	static class ReplayListener extends ListenerAdapter {</span>


		@Override
		public void onGenericMessage(GenericMessageEvent event) throws Exception {
<span class="nc bnc" id="L171" title="All 2 branches missed.">			if (event.getMessage().startsWith(&quot;?dumpusers&quot;)) {</span>
<span class="nc" id="L172">				System.out.println(&quot;===command dumpusers start===&quot;);</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">				for (User curUser : event.getBot().getUserChannelDao().getAllUsers()) log.debug(curUser.getNick() + &quot;!&quot; + curUser.getLogin() + &quot;@&quot; + curUser.getHostname() + &quot; - &quot; + curUser.getHostmask());</span>
<span class="nc" id="L174">				System.out.println(&quot;===command dumpusers end===&quot;);</span>
			}
<span class="nc" id="L176">		}</span>
	}

	public static void replayFile(File file) throws Exception {
<span class="nc" id="L180">		replayFile(file, generateConfig());</span>
<span class="nc" id="L181">	}</span>

	public static void replayFile(File file, Configuration.Builder config) throws Exception {
<span class="nc bnc" id="L184" title="All 2 branches missed.">		if (!file.exists()) {</span>
<span class="nc" id="L185">			throw new IOException(&quot;File &quot; + file + &quot; does not exist&quot;);</span>
		}
<span class="nc" id="L187">		FileInputStream fileInput = new FileInputStream(file);</span>
		try {
<span class="nc" id="L189">			replay(config, fileInput, &quot;file &quot; + file.getCanonicalPath());</span>
		} finally {
<span class="nc bnc" id="L191" title="All 4 branches missed.">			if (java.util.Collections.singletonList(fileInput).get(0) != null) {</span>
<span class="nc" id="L192">				fileInput.close();</span>
			}
<span class="nc" id="L194">		}</span>
<span class="nc" id="L195">	}</span>

	public static Configuration.Builder generateConfig() {
<span class="nc" id="L198">		return new Configuration.Builder().setName(&quot;QuackPirc&quot;).setLogin(&quot;QP&quot;).addServer(&quot;example.com&quot;).setNickservPassword(System.getProperty(&quot;nickserv&quot;)).setMessageDelay(new StaticDelay(0)).setListenerManager(new GenericListenerManager()).setShutdownHookEnabled(false);</span>
	}

	public static void replay(Configuration.Builder config, InputStream input, String title) throws Exception {
<span class="nc" id="L202">		log.info(&quot;---Replaying {}---&quot;, title);</span>
<span class="nc" id="L203">		StopWatch timer = new StopWatch();</span>
<span class="nc" id="L204">		timer.start();</span>
		//Wrap listener manager with ours that siphons off events
<span class="nc" id="L206">		final Queue&lt;Event&gt; eventQueue = Lists.newLinkedList();</span>
<span class="nc" id="L207">		WrapperListenerManager newManager = new WrapperListenerManager(config.getListenerManager(), eventQueue);</span>
<span class="nc" id="L208">		config.setListenerManager(newManager);</span>
<span class="nc" id="L209">		config.addListener(new ReplayListener());</span>
<span class="nc" id="L210">		final LinkedList&lt;String&gt; outputQueue = Lists.newLinkedList();</span>
<span class="nc" id="L211">		ReplayPircBotX bot = new ReplayPircBotX(config.buildConfiguration(), outputQueue);</span>
<span class="nc" id="L212">		BufferedReader fileInput = new BufferedReader(new InputStreamReader(input));</span>
<span class="nc" id="L213">		boolean skippedHeader = false;</span>
		while (true) {
<span class="nc" id="L215">			String lineRaw = fileInput.readLine();</span>
<span class="nc bnc" id="L216" title="All 4 branches missed.">			if (bot.isClosed() &amp;&amp; StringUtils.isNotBlank(lineRaw)) {</span>
<span class="nc" id="L217">				throw new RuntimeException(&quot;bot is closed but file still has line &quot; + lineRaw);</span>
<span class="nc bnc" id="L218" title="All 4 branches missed.">			} else if (!bot.isClosed() &amp;&amp; StringUtils.isBlank(lineRaw)) {</span>
<span class="nc" id="L219">				throw new RuntimeException(&quot;bot is not closed but file doesn\'t have any more lines&quot;);</span>
<span class="nc bnc" id="L220" title="All 4 branches missed.">			} else if (bot.isClosed() &amp;&amp; StringUtils.isBlank(lineRaw)) {</span>
<span class="nc" id="L221">				log.debug(&quot;(done) Bot is closed and file doesn\'t have any more lines&quot;);</span>
<span class="nc" id="L222">				break;</span>
			}
<span class="nc" id="L224">			log.debug(&quot;(line) &quot; + lineRaw);</span>
<span class="nc" id="L225">			String[] lineParts = StringUtils.split(lineRaw, &quot; &quot;, 2);</span>
<span class="nc" id="L226">			String command = lineParts[0];</span>
<span class="nc" id="L227">			String line = lineParts[1];</span>
			//For now skip the info lines PircBotX is supposed to send on connect
			//They are only sent when connect() is called which requires multithreading
<span class="nc bnc" id="L230" title="All 2 branches missed.">			if (!skippedHeader) {</span>
<span class="nc bnc" id="L231" title="All 4 branches missed.">				if (command.equals(&quot;pircbotx.output&quot;)) continue; else if (command.equals(&quot;pircbotx.input&quot;)) {</span>
<span class="nc" id="L232">					log.debug(&quot;Finished skipping header&quot;);</span>
<span class="nc" id="L233">					skippedHeader = true;</span>
<span class="nc" id="L234">				} else throw new RuntimeException(&quot;Unknown line &quot; + lineRaw);</span>
			}
<span class="nc bnc" id="L236" title="All 2 branches missed.">			if (command.equals(&quot;pircbotx.input&quot;)) {</span>
<span class="nc" id="L237">				bot.getInputParser().handleLine(line);</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">			} else if (command.equals(&quot;pircbotx.output&quot;)) {</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">				String lastOutput = outputQueue.isEmpty() ? null : outputQueue.pop();</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">				if (StringUtils.startsWith(line, &quot;JOIN&quot;)) {</span>
<span class="nc" id="L241">					log.debug(&quot;Skipping JOIN output, server should send its own JOIN&quot;);</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">				} else if (StringUtils.startsWith(line, &quot;QUIT&quot;)) {</span>
<span class="nc" id="L243">					log.debug(&quot;Skipping QUIT output, server should send its own QUIT&quot;);</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">				} else if (!line.equals(lastOutput)) {</span>
<span class="nc" id="L245">					log.error(&quot;Expected last output: &quot; + line);</span>
<span class="nc" id="L246">					log.error(&quot;Given last output: &quot; + lastOutput);</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">					for (String curOutput : outputQueue) {</span>
<span class="nc" id="L248">						log.error(&quot;Queued output: &quot; + curOutput);</span>
<span class="nc" id="L249">					}</span>
<span class="nc" id="L250">					throw new RuntimeException(&quot;Failed to verify output (see log)&quot;);</span>
				}
<span class="nc" id="L252">			} else {</span>
<span class="nc" id="L253">				throw new RuntimeException(&quot;Unknown line &quot; + lineRaw);</span>
			}
<span class="nc bnc" id="L255" title="All 2 branches missed.">			for (Event curEvent : Iterables.consumingIterable(eventQueue)) log.debug(&quot;(events) &quot; + curEvent);</span>
<span class="nc" id="L256">			log.debug(&quot;&quot;);</span>
<span class="nc" id="L257">		}</span>
<span class="nc" id="L258">		timer.stop();</span>
<span class="nc" id="L259">		log.debug(&quot;---Replay successful in {}---&quot;, DurationFormatUtils.formatDuration(timer.getTime(), &quot;mm\'min\'ss\'sec\'SSS\'ms\'&quot;));</span>
<span class="nc" id="L260">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>