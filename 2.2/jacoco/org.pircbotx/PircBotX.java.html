<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PircBotX.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pircbotx</a> &gt; <a href="index.source.html" class="el_package">org.pircbotx</a> &gt; <span class="el_source">PircBotX.java</span></div><h1>PircBotX.java</h1><pre class="source lang-java linenums">// Generated by delombok at Mon Apr 13 22:36:03 CEST 2020
/**
 * Copyright (C) 2010-2014 Leon Blakey &lt;lord.quackstar at gmail.com&gt;
 *
 * This file is part of PircBotX.
 *
 * PircBotX is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * PircBotX is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * PircBotX. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.pircbotx;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Maps;
import com.google.common.primitives.Ints;
import java.io.BufferedReader;
import java.io.Closeable;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.InterruptedIOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.lang.ref.WeakReference;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import lombok.NonNull;
import org.apache.commons.lang3.StringUtils;
import org.pircbotx.dcc.DccHandler;
import org.pircbotx.exception.IrcException;
import org.pircbotx.hooks.ListenerAdapter;
import org.pircbotx.hooks.events.*;
import org.pircbotx.output.OutputCAP;
import org.pircbotx.output.OutputDCC;
import org.pircbotx.output.OutputIRC;
import org.pircbotx.output.OutputRaw;
import org.pircbotx.snapshot.UserChannelDaoSnapshot;

/**
 * PircBotX is a Java framework for writing IRC bots quickly and easily.
 * &lt;p&gt;
 * It provides an event-driven architecture to handle common IRC events, flood
 * protection, DCC support, ident support, and more. 
 * &lt;p&gt;
 * Methods of the PircBotX class can be called to send events to the IRC server
 * that it connects to. For example, calling the sendMessage method will send a
 * message to a channel or user on the IRC server. Multiple servers can be
 * supported using multiple instances of PircBotX.
 * &lt;p&gt;
 * To perform an action when the PircBotX receives a normal message from the IRC
 * server, you would listen for the MessageEvent in your listener (see
 * {@link ListenerAdapter}). Many other events are dispatched as well for other
 * incoming lines
 *
 * @author Origionally by:
 * &lt;a href=&quot;http://www.jibble.org/&quot;&gt;Paul James Mutton&lt;/a&gt; for &lt;a
 * href=&quot;http://www.jibble.org/pircbot.php&quot;&gt;PircBot&lt;/a&gt;
 * &lt;p&gt;
 * Forked and Maintained by Leon Blakey in &lt;a
 * href=&quot;http://github.com/thelq/pircbotx&quot;&gt;PircBotX&lt;/a&gt;
 */
public class PircBotX implements Comparable&lt;PircBotX&gt;, Closeable {
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
<span class="fc" id="L77">	private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(PircBotX.class);</span>
	//THIS LINE IS AUTOGENERATED, DO NOT EDIT
	/**
	 * The definitive version number of this release of PircBotX.
	 */
	public static final String VERSION = &quot;2.2&quot;;
<span class="fc" id="L83">	protected static final AtomicInteger BOT_COUNT = new AtomicInteger();</span>
	
	/**
	 * Unique number for this bot
	 */
	protected final int botId;
	//Utility objects
	/**
	 * Configuration used for this bot
	 */
	protected final Configuration configuration;
	protected final InputParser inputParser;
	
	/**
	 * User-Channel mapper
	 */
	protected final UserChannelDao&lt;User, Channel&gt; userChannelDao;
	protected final DccHandler dccHandler;
	protected final ServerInfo serverInfo;
	//Connection stuff.
	protected Socket socket;
	protected BufferedReader inputReader;
	protected Writer outputWriter;
	protected final OutputRaw outputRaw;
	protected final OutputIRC outputIRC;
	protected final OutputCAP outputCAP;
	protected final OutputDCC outputDCC;
	
	/**
	 * Enabled CAP features
	 */
<span class="fc" id="L114">	protected List&lt;String&gt; enabledCapabilities = new ArrayList&lt;String&gt;();</span>
	protected String nick;
<span class="fc" id="L116">	protected boolean loggedIn = false;</span>
	protected Thread shutdownHook;
<span class="fc" id="L118">	protected volatile boolean reconnectStopped = false;</span>
	protected ImmutableMap&lt;String, String&gt; reconnectChannels;
<span class="fc" id="L120">	private State state = State.INIT;</span>
<span class="fc" id="L121">	protected final Object stateLock = new Object();</span>
	protected Exception disconnectException;
	protected String serverHostname;
	protected int serverPort;
	
	/**
	 */
<span class="fc" id="L128">	protected boolean nickservIdentified = false;</span>
<span class="fc" id="L129">	private int connectAttempts = 0;</span>
<span class="fc" id="L130">	private int connectAttemptTotal = 0;</span>
	
	/**
	 * Constructs a PircBotX with the provided configuration.
	 *
	 * @param configuration Fully built Configuration
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L138">	public PircBotX(@NonNull Configuration configuration) {</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">		if (configuration == null) {</span>
<span class="nc" id="L140">			throw new java.lang.NullPointerException(&quot;configuration&quot;);</span>
		}
<span class="fc" id="L142">		botId = BOT_COUNT.getAndIncrement();</span>
<span class="fc" id="L143">		this.configuration = configuration;</span>
<span class="fc" id="L144">		this.nick = configuration.getName();</span>
		//Pre-insert an initial User representing the bot itself
<span class="fc" id="L146">		this.userChannelDao = configuration.getBotFactory().createUserChannelDao(this);</span>
<span class="fc" id="L147">		UserHostmask botHostmask = configuration.getBotFactory().createUserHostmask(this, null, configuration.getName(), configuration.getLogin(), null);</span>
<span class="fc" id="L148">		getUserChannelDao().createUser(botHostmask);</span>
<span class="fc" id="L149">		this.serverInfo = configuration.getBotFactory().createServerInfo(this);</span>
<span class="fc" id="L150">		this.outputRaw = configuration.getBotFactory().createOutputRaw(this);</span>
<span class="fc" id="L151">		this.outputIRC = configuration.getBotFactory().createOutputIRC(this);</span>
<span class="fc" id="L152">		this.outputCAP = configuration.getBotFactory().createOutputCAP(this);</span>
<span class="fc" id="L153">		this.outputDCC = configuration.getBotFactory().createOutputDCC(this);</span>
<span class="fc" id="L154">		this.dccHandler = configuration.getBotFactory().createDccHandler(this);</span>
<span class="fc" id="L155">		this.inputParser = configuration.getBotFactory().createInputParser(this);</span>
<span class="fc" id="L156">	}</span>
	
	/**
	 * Start the bot by connecting to the server. If
	 * {@link Configuration#isAutoReconnect()} is true this will continuously
	 * reconnect to the server until {@link #stopBotReconnect() } is called or
	 * an exception is thrown from connecting
	 *
	 * @throws IOException if it was not possible to connect to the server.
	 * @throws IrcException
	 */
	public void startBot() throws IOException, IrcException {
		//Begin magic
<span class="fc" id="L169">		reconnectStopped = false;</span>
		do {
			//Try to connect to the server, grabbing any exceptions
<span class="fc" id="L172">			LinkedHashMap&lt;InetSocketAddress, Exception&gt; connectExceptions = Maps.newLinkedHashMap();</span>
			try {
<span class="fc" id="L174">				connectAttemptTotal++;</span>
<span class="fc" id="L175">				connectAttempts++;</span>
<span class="fc" id="L176">				connectExceptions.putAll(connect());</span>
<span class="nc" id="L177">			} catch (Exception e) {</span>
				//Initial connect exceptions are returned in the map, this is a more serious error
<span class="nc" id="L179">				log.error(&quot;Exception encountered during connect&quot;, e);</span>
<span class="nc" id="L180">				connectExceptions.put(new InetSocketAddress(serverHostname, serverPort), e);</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">				if (!configuration.isAutoReconnect()) throw new RuntimeException(&quot;Exception encountered during connect&quot;, e);</span>
			} finally {
<span class="pc bpc" id="L183" title="5 of 6 branches missed.">				if (!connectExceptions.isEmpty()) Utils.dispatchEvent(this, new ConnectAttemptFailedEvent(this, configuration.getAutoReconnectAttempts() - connectAttempts, ImmutableMap.copyOf(connectExceptions)));</span>
				//Cleanup if not already called
<span class="pc" id="L185">				synchronized (stateLock) {</span>
<span class="pc bpc" id="L186" title="4 of 6 branches missed.">					if (state != State.DISCONNECTED) shutdown();</span>
<span class="pc" id="L187">				}</span>
<span class="pc" id="L188">			}</span>
			//No longer connected to the server
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">			if (!configuration.isAutoReconnect()) return;</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">			if (reconnectStopped) {</span>
<span class="nc" id="L192">				log.debug(&quot;stopBotReconnect() called, exiting reconnect loop&quot;);</span>
<span class="nc" id="L193">				return;</span>
			}
<span class="nc bnc" id="L195" title="All 2 branches missed.">			if (connectAttempts == configuration.getAutoReconnectAttempts()) {</span>
<span class="nc" id="L196">				throw new IOException(&quot;Failed to connect to IRC server(s) after &quot; + connectAttempts + &quot; attempts&quot;);</span>
			}
			//Optionally pause between attempts, useful if network is temporarily down
<span class="nc bnc" id="L199" title="All 2 branches missed.">			if (configuration.getAutoReconnectDelay().getDelay() &gt; 0) try {</span>
<span class="nc" id="L200">				log.debug(&quot;Pausing for {} milliseconds before connecting again&quot;, configuration.getAutoReconnectDelay());</span>
<span class="nc" id="L201">				Thread.sleep(configuration.getAutoReconnectDelay().getDelay());</span>
<span class="nc" id="L202">			} catch (InterruptedException e) {</span>
<span class="nc" id="L203">				throw new RuntimeException(&quot;Interrupted while pausing before the next connect attempt&quot;, e);</span>
<span class="nc" id="L204">			}</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">		}		 while (connectAttempts &lt; configuration.getAutoReconnectAttempts());</span>
<span class="nc" id="L206">	}</span>
	
	/**
	 * Do not try connecting again in the future.
	 */
	public void stopBotReconnect() {
<span class="nc" id="L212">		reconnectStopped = true;</span>
<span class="nc" id="L213">	}</span>
	
	/**
	 * Attempt to connect to the specified IRC server using the supplied port
	 * number, password, and socketFactory. On success a {@link ConnectEvent}
	 * will be dispatched
	 *
	 * @throws IOException if it was not possible to connect to the server.
	 * @throws IrcException if the server would not let us join it.
	 */
	protected ImmutableMap&lt;InetSocketAddress, Exception&gt; connect() throws IOException, IrcException {
<span class="fc" id="L224">		synchronized (stateLock) {</span>
			//Server id
<span class="fc" id="L226">			Utils.addBotToMDC(this);</span>
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">			if (isConnected()) throw new IrcException(IrcException.Reason.ALREADY_CONNECTED, &quot;Must disconnect from server before connecting again&quot;);</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">			if (getState() == State.CONNECTED) throw new RuntimeException(&quot;Bot is not connected but state is State.CONNECTED. This shouldn\'t happen&quot;);</span>
<span class="pc bpc" id="L229" title="3 of 4 branches missed.">			if (configuration.isIdentServerEnabled() &amp;&amp; IdentServer.getServer() == null) throw new RuntimeException(&quot;UseIdentServer is enabled but no IdentServer has been started&quot;);</span>
			//Reset capabilities
<span class="fc" id="L231">			enabledCapabilities = new ArrayList&lt;String&gt;();</span>
			//Pre-insert an initial User representing the bot itself
<span class="fc" id="L233">			getUserChannelDao().close();</span>
<span class="fc" id="L234">			UserHostmask botHostmask = configuration.getBotFactory().createUserHostmask(this, null, configuration.getName(), configuration.getLogin(), null);</span>
<span class="fc" id="L235">			getUserChannelDao().createUser(botHostmask);</span>
			//On each server the user gives us, try to connect to all the IP addresses
<span class="fc" id="L237">			ImmutableMap.Builder&lt;InetSocketAddress, Exception&gt; connectExceptions = ImmutableMap.builder();</span>
<span class="fc" id="L238">			int serverEntryCounter = 0;</span>
			ServerEntryLoop:
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">			for (Configuration.ServerEntry curServerEntry : configuration.getServers()) {</span>
<span class="fc" id="L241">				serverEntryCounter++;</span>
<span class="fc" id="L242">				serverHostname = curServerEntry.getHostname();</span>
				//Hostname and port
<span class="fc" id="L244">				Utils.addBotToMDC(this);</span>
<span class="fc" id="L245">				log.info(&quot;---Starting Connect attempt {}/{}&quot;, connectAttempts, configuration.getAutoReconnectAttempts() + &quot;---&quot;);</span>
<span class="fc" id="L246">				int serverAddressCounter = 0;</span>
<span class="fc" id="L247">				InetAddress[] serverAddresses = InetAddress.getAllByName(serverHostname);</span>
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">				for (InetAddress curAddress : serverAddresses) {</span>
<span class="fc" id="L249">					serverAddressCounter++;</span>
<span class="fc" id="L250">					String debug = Utils.format(&quot;[{}/{} address left from {}, {}/{} hostnames left] &quot;, String.valueOf(serverAddresses.length - serverAddressCounter), String.valueOf(serverAddresses.length), serverHostname, String.valueOf(configuration.getServers().size() - serverEntryCounter), String.valueOf(configuration.getServers().size()));</span>
<span class="fc" id="L251">					log.debug(&quot;{}Atempting to connect to {} on port {}&quot;, debug, curAddress, curServerEntry.getPort());</span>
					try {
<span class="fc" id="L253">						socket = configuration.getSocketFactory().createSocket();</span>
<span class="fc" id="L254">						socket.bind(new InetSocketAddress(configuration.getLocalAddress(), 0));</span>
<span class="fc" id="L255">						socket.connect(new InetSocketAddress(curAddress, curServerEntry.getPort()), configuration.getSocketConnectTimeout());</span>
						//No exception, assume successful
<span class="fc" id="L257">						serverPort = curServerEntry.getPort();</span>
<span class="fc" id="L258">						break ServerEntryLoop;</span>
<span class="nc" id="L259">					} catch (Exception e) {</span>
<span class="nc" id="L260">						connectExceptions.put(new InetSocketAddress(curAddress, curServerEntry.getPort()), e);</span>
<span class="nc" id="L261">						log.warn(&quot;{}Failed to connect to {} on port {}&quot;, debug, curAddress, curServerEntry.getPort(), e);</span>
					}
				}
<span class="nc" id="L264">			}</span>
			//Make sure were connected
<span class="pc bpc" id="L266" title="3 of 6 branches missed.">			if (socket == null || (socket != null &amp;&amp; !socket.isConnected())) {</span>
<span class="nc" id="L267">				return connectExceptions.build();</span>
			}
<span class="fc" id="L269">			state = State.CONNECTED;</span>
<span class="fc" id="L270">			socket.setSoTimeout(configuration.getSocketTimeout());</span>
<span class="fc" id="L271">			log.info(&quot;Connected to server.&quot;);</span>
<span class="fc" id="L272">			changeSocket(socket);</span>
<span class="pc" id="L273">		}</span>
<span class="fc" id="L274">		configuration.getListenerManager().onEvent(new SocketConnectEvent(this));</span>
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">		if (configuration.isIdentServerEnabled()) IdentServer.getServer().addIdentEntry(socket.getInetAddress(), socket.getPort(), socket.getLocalPort(), configuration.getLogin());</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">		if (configuration.isCapEnabled()) </span>
		// Attempt to initiate a CAP transaction.
<span class="fc" id="L278">		sendCAP().getSupported();</span>
		// Attempt to join the server.
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">		if (configuration.isWebIrcEnabled()) sendRaw().rawLineNow(&quot;WEBIRC &quot; + configuration.getWebIrcPassword() + &quot; &quot; + configuration.getWebIrcUsername() + &quot; &quot; + configuration.getWebIrcHostname() + &quot; &quot; + configuration.getWebIrcAddress().getHostAddress());</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">		if (StringUtils.isNotBlank(configuration.getServerPassword())) sendRaw().rawLineNow(&quot;PASS &quot; + configuration.getServerPassword());</span>
<span class="fc" id="L282">		sendRaw().rawLineNow(&quot;NICK &quot; + configuration.getName());</span>
<span class="fc" id="L283">		sendRaw().rawLineNow(&quot;USER &quot; + configuration.getLogin() + &quot; 8 * :&quot; + configuration.getRealName());</span>
		//Start input to start accepting lines
<span class="fc" id="L285">		startLineProcessing();</span>
<span class="fc" id="L286">		return ImmutableMap.of();</span>
	}
	
	protected void changeSocket(Socket socket) throws IOException {
<span class="fc" id="L290">		this.socket = socket;</span>
<span class="fc" id="L291">		this.inputReader = new BufferedReader(new InputStreamReader(socket.getInputStream(), configuration.getEncoding()));</span>
<span class="fc" id="L292">		this.outputWriter = new OutputStreamWriter(socket.getOutputStream(), configuration.getEncoding());</span>
<span class="fc" id="L293">	}</span>
	
	protected void startLineProcessing() {
<span class="fc bfc" id="L296" title="All 2 branches covered.">		while (processNextLine()) {</span>
			//see processNextLine
		}
		//Now that the socket is definitely closed call event, log, and kill the OutputThread
<span class="fc" id="L300">		shutdown();</span>
<span class="fc" id="L301">	}</span>
	
	/**
	 * @return true to continue, false to end
	 */
	protected boolean processNextLine() {
		//Get line from the server
		String line;
		try {
<span class="fc" id="L310">			line = inputReader.readLine();</span>
<span class="nc" id="L311">		} catch (InterruptedIOException iioe) {</span>
			// This will happen if we haven't received anything from the server for a while.
			// So we shall send it a ping to check that we are still connected.
<span class="nc" id="L314">			sendRaw().rawLine(&quot;PING &quot; + (System.currentTimeMillis() / 1000));</span>
			// Now we go back to listening for stuff from the server...
<span class="nc" id="L316">			return true;</span>
<span class="nc" id="L317">		} catch (Exception e) {</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">			if (Thread.interrupted()) {</span>
<span class="nc" id="L319">				log.error(&quot;--- PircBotX interrupted during read, aborting reconnect loop and shutting down ---&quot;);</span>
<span class="nc" id="L320">				stopBotReconnect();</span>
<span class="nc" id="L321">				return false;</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">			} else if (socket.isClosed()) {</span>
<span class="nc" id="L323">				log.info(&quot;Socket is closed, stopping read loop and shutting down&quot;);</span>
<span class="nc" id="L324">				return false;</span>
			} else {
<span class="nc" id="L326">				disconnectException = e;</span>
				//Something is wrong. Assume its bad and begin disconnect
<span class="nc" id="L328">				String debug = &quot;Exception encountered when reading next line from server&quot;;</span>
<span class="nc" id="L329">				log.error(debug, e);</span>
<span class="nc" id="L330">				Utils.dispatchEvent(this, new ExceptionEvent(this, e, debug));</span>
<span class="nc" id="L331">				line = null;</span>
			}
<span class="fc" id="L333">		}</span>
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">		if (Thread.interrupted()) {</span>
<span class="nc" id="L335">			log.error(&quot;--- PircBotX interrupted during read, aborting reconnect loop and shutting down ---&quot;);</span>
<span class="nc" id="L336">			stopBotReconnect();</span>
<span class="nc" id="L337">			return false;</span>
		}
		//End the loop if the line is null
<span class="fc bfc" id="L340" title="All 2 branches covered.">		if (line == null) return false;</span>
		//Start acting the line
		try {
<span class="fc" id="L343">			inputParser.handleLine(line);</span>
<span class="fc" id="L344">		} catch (Exception e) {</span>
			//Exception in client code. Just log and continue
<span class="fc" id="L346">			String debug = &quot;Exception encountered when parsing line &quot; + line;</span>
<span class="fc" id="L347">			log.error(debug, e);</span>
<span class="fc" id="L348">			Utils.dispatchEvent(this, new ExceptionEvent(this, e, debug));</span>
<span class="fc" id="L349">		}</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">		if (Thread.interrupted()) {</span>
<span class="nc" id="L351">			log.error(&quot;--- PircBotX interrupted during parsing, aborting reconnect loop and shutting down ---&quot;);</span>
<span class="nc" id="L352">			stopBotReconnect();</span>
<span class="nc" id="L353">			return false;</span>
		}
<span class="fc" id="L355">		return true;</span>
	}
	
	/**
	 * Actually sends the raw line to the server. This method is NOT
	 * SYNCHRONIZED since it's only called from methods that handle locking
	 *
	 * @param line
	 * @throws java.io.IOException
	 */
	protected void sendRawLineToServer(String line) throws IOException {
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">		if (line.length() &gt; configuration.getMaxLineLength() - 2) line = line.substring(0, configuration.getMaxLineLength() - 2);</span>
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">		if (line.indexOf('\n') &gt; -1) line = line.substring(0, line.indexOf('\n')).trim();// do NOT send messages containing newlines</span>
<span class="fc" id="L368">		outputWriter.write(line + &quot;\r\n&quot;);</span>
<span class="fc" id="L369">		outputWriter.flush();</span>
<span class="fc" id="L370">		List&lt;String&gt; lineParts = Utils.tokenizeLine(line);</span>
<span class="fc" id="L371">		getConfiguration().getListenerManager().onEvent(new OutputEvent(this, line, lineParts));</span>
<span class="fc" id="L372">	}</span>
	
	protected void onLoggedIn(String nick) {
<span class="fc" id="L375">		this.loggedIn = true;</span>
<span class="fc" id="L376">		setNick(nick);</span>
		//Were probably connected to the server at this point
<span class="fc" id="L378">		this.connectAttempts = 0;</span>
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">		if (configuration.isShutdownHookEnabled()) Runtime.getRuntime().addShutdownHook(shutdownHook = new PircBotX.BotShutdownHook(this));</span>
<span class="fc" id="L380">	}</span>
	
	public OutputRaw sendRaw() {
<span class="fc" id="L383">		return outputRaw;</span>
	}
	
	public OutputIRC sendIRC() {
<span class="fc" id="L387">		return outputIRC;</span>
	}
	
	/**
	 * use sendIRC() instead
	 */
	@Deprecated
	public OutputIRC send() {
<span class="nc" id="L395">		return outputIRC;</span>
	}
	
	public OutputCAP sendCAP() {
<span class="fc" id="L399">		return outputCAP;</span>
	}
	
	public OutputDCC sendDCC() {
<span class="nc" id="L403">		return outputDCC;</span>
	}
	
	/**
	 * Sets the internal nick of the bot. This is only to be called by the
	 * PircBotX class in response to notification of nick changes that apply to
	 * us.
	 *
	 * @param nick The new nick.
	 */
	protected void setNick(String nick) {
<span class="fc" id="L414">		this.nick = nick;</span>
<span class="fc" id="L415">	}</span>
	
	/**
	 * Returns the current nick of the bot. Note that if you have just changed
	 * your nick, this method will still return the old nick until confirmation
	 * of the nick change is received from the server.
	 *
	 * @since PircBot 1.0.0
	 *
	 * @return The current nick of the bot.
	 */
	public String getNick() {
<span class="fc" id="L427">		return nick;</span>
	}
	
	/**
	 * Returns whether or not the PircBotX is currently connected to a server.
	 * The result of this method should only act as a rough guide, as the result
	 * may not be valid by the time you act upon it.
	 *
	 * @return True if and only if the PircBotX is currently connected to a
	 * server.
	 */
	public boolean isConnected() {
<span class="fc" id="L439">		synchronized (this.stateLock) {</span>
<span class="pc bpc" id="L440" title="1 of 4 branches missed.">			return socket != null &amp;&amp; !socket.isClosed();</span>
<span class="nc" id="L441">		}</span>
	}
	
	/**
	 * Returns a String representation of this object. You may find this useful
	 * for debugging purposes, particularly if you are using more than one
	 * PircBotX instance to achieve multiple server connectivity. The format of
	 * this String may change between different versions of PircBotX but is
	 * currently something of the form 	 &lt;code&gt;
	 * Version{PircBotX x.y.z Java IRC Bot - www.jibble.org}
	 * Connected{true}
	 * Server{irc.dal.net}
	 * Port{6667}
	 * Password{}
	 * &lt;/code&gt;
	 *
	 * @since PircBot 0.9.10
	 *
	 * @return a String representation of this object.
	 */
	@Override
	public String toString() {
<span class="fc" id="L463">		return &quot;Version{&quot; + configuration.getVersion() + &quot;} Connected{&quot; + isConnected() + &quot;} Server{&quot; + getServerHostname() + &quot;} Port{&quot; + getServerPort() + &quot;}&quot;;</span>
	}
	
	/**
	 * Gets the bots own user object.
	 *
	 * @return The user object representing this bot
	 * @see UserChannelDao#getUserBot()
	 */
	public User getUserBot() {
<span class="fc" id="L473">		return userChannelDao.getUser(getNick());</span>
	}
	
	/**
	 * @return the serverInfo
	 */
	public ServerInfo getServerInfo() {
<span class="fc" id="L480">		return serverInfo;</span>
	}
	
	public InetAddress getLocalAddress() {
<span class="nc" id="L484">		return socket.getLocalAddress();</span>
	}
	
	public int getConnectionId() {
<span class="fc" id="L488">		return connectAttemptTotal;</span>
	}
	
	/**
	 * Get the auto reconnect channels and clear local copy
	 *
	 * @return
	 */
	protected ImmutableMap&lt;String, String&gt; reconnectChannels() {
<span class="fc" id="L497">		ImmutableMap&lt;String, String&gt; reconnectChannelsLocal = reconnectChannels;</span>
<span class="fc" id="L498">		reconnectChannels = null;</span>
<span class="fc" id="L499">		return reconnectChannelsLocal;</span>
	}
	
	/**
	 * If for some reason you absolutely need to stop PircBotX now instead of
	 * gracefully closing with {@link OutputIRC#quitServer() }, this will close
	 * the socket which causes read loop to terminate which will shutdown
	 * PircBotX shortly.
	 *
	 * @see OutputIRC#quitServer()
	 */
	public void close() {
		try {
<span class="fc" id="L512">			socket.close();</span>
<span class="nc" id="L513">		} catch (Exception e) {</span>
<span class="nc" id="L514">			log.error(&quot;Can\'t close socket&quot;, e);</span>
<span class="fc" id="L515">		}</span>
<span class="fc" id="L516">	}</span>
	
	/**
	 * Fully shutdown the bot and all internal resources. This will close the
	 * connections to the server, kill background threads, clear server specific
	 * state, and dispatch a DisconnectedEvent
	 */
	protected void shutdown() {
		UserChannelDaoSnapshot daoSnapshot;
<span class="fc" id="L525">		synchronized (stateLock) {</span>
<span class="fc" id="L526">			log.debug(&quot;---PircBotX shutdown started---&quot;);</span>
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">			if (state == State.DISCONNECTED) throw new RuntimeException(&quot;Cannot call shutdown twice&quot;);</span>
<span class="fc" id="L528">			state = State.DISCONNECTED;</span>
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">			if (configuration.isIdentServerEnabled()) IdentServer.getServer().removeIdentEntry(socket.getInetAddress(), socket.getPort(), socket.getLocalPort(), configuration.getLogin());</span>
			//Close the socket from here and let the threads die
<span class="pc bpc" id="L531" title="2 of 4 branches missed.">			if (socket != null &amp;&amp; !socket.isClosed()) try {</span>
<span class="fc" id="L532">				socket.close();</span>
<span class="nc" id="L533">			} catch (Exception e) {</span>
<span class="nc" id="L534">				log.error(&quot;Cannot close socket&quot;, e);</span>
<span class="fc" id="L535">			}</span>
			//Cache channels for possible next reconnect
<span class="fc" id="L537">			ImmutableMap.Builder&lt;String, String&gt; reconnectChannelsBuilder = ImmutableMap.builder();</span>
<span class="pc bpc" id="L538" title="1 of 2 branches missed.">			for (Channel curChannel : userChannelDao.getAllChannels()) {</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">				String key = (curChannel.getChannelKey() == null) ? &quot;&quot; : curChannel.getChannelKey();</span>
<span class="nc" id="L540">				reconnectChannelsBuilder.put(curChannel.getName(), key);</span>
<span class="nc" id="L541">			}</span>
<span class="fc" id="L542">			reconnectChannels = reconnectChannelsBuilder.build();</span>
			//Clear relevant variables of information
<span class="fc" id="L544">			loggedIn = false;</span>
<span class="pc bpc" id="L545" title="1 of 2 branches missed.">			daoSnapshot = (configuration.isSnapshotsEnabled()) ? userChannelDao.createSnapshot() : null;</span>
<span class="fc" id="L546">			userChannelDao.close();</span>
<span class="fc" id="L547">			inputParser.close();</span>
<span class="fc" id="L548">			dccHandler.close();</span>
<span class="pc" id="L549">		}</span>
		//Dispatch event
<span class="fc" id="L551">		configuration.getListenerManager().onEvent(new DisconnectEvent(this, daoSnapshot, disconnectException));</span>
<span class="fc" id="L552">		disconnectException = null;</span>
<span class="fc" id="L553">		log.debug(&quot;Disconnected.&quot;);</span>
		//Shutdown listener manager
<span class="fc" id="L555">		configuration.getListenerManager().shutdown(this);</span>
<span class="fc" id="L556">	}</span>
	
	/**
	 * Compare {@link #getBotId() bot id's}. This is useful for sorting lists of
	 * Channel objects.
	 *
	 * @param other Other channel to compare to
	 * @return the result of calling compareToIgnoreCase on channel names.
	 */
	public int compareTo(PircBotX other) {
<span class="nc" id="L566">		return Ints.compare(getBotId(), other.getBotId());</span>
	}
	
	/**
	 * @return the state
	 */
	public State getState() {
<span class="fc" id="L573">		synchronized (this.stateLock) {</span>
<span class="fc" id="L574">			return state;</span>
<span class="nc" id="L575">		}</span>
	}
	
	protected static class BotShutdownHook extends Thread {
		protected final WeakReference&lt;PircBotX&gt; thisBotRef;
		
<span class="nc" id="L581">		public BotShutdownHook(PircBotX bot) {</span>
<span class="nc" id="L582">			this.thisBotRef = new WeakReference&lt;PircBotX&gt;(bot);</span>
<span class="nc" id="L583">			setName(&quot;bot&quot; + BOT_COUNT + &quot;-shutdownhook&quot;);</span>
<span class="nc" id="L584">		}</span>
		
		@Override
		public void run() {
<span class="nc" id="L588">			PircBotX thisBot = thisBotRef.get();</span>
<span class="nc bnc" id="L589" title="All 4 branches missed.">			if (thisBot != null &amp;&amp; thisBot.getState() != PircBotX.State.DISCONNECTED) {</span>
<span class="nc" id="L590">				thisBot.stopBotReconnect();</span>
<span class="nc" id="L591">				thisBot.sendIRC().quitServer();</span>
				try {
<span class="nc bnc" id="L593" title="All 2 branches missed.">					if (thisBot.isConnected()) thisBot.socket.close();</span>
<span class="nc" id="L594">				} catch (IOException ex) {</span>
<span class="nc" id="L595">					log.debug(&quot;Unabloe to forcibly close socket&quot;, ex);</span>
<span class="nc" id="L596">				}</span>
			}
<span class="nc" id="L598">		}</span>
	}
	
<span class="pc" id="L601">	public enum State {</span>
<span class="fc" id="L602">		INIT,</span>
<span class="fc" id="L603">		CONNECTED,</span>
<span class="fc" id="L604">		DISCONNECTED;</span>
		
	}
	
	@java.lang.Override
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public boolean equals(final java.lang.Object o) {
<span class="pc bpc" id="L612" title="1 of 2 branches missed.">		if (o == this) return true;</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">		if (!(o instanceof PircBotX)) return false;</span>
<span class="nc" id="L614">		final PircBotX other = (PircBotX)o;</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">		if (!other.canEqual((java.lang.Object)this)) return false;</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">		if (this.getBotId() != other.getBotId()) return false;</span>
<span class="nc" id="L617">		return true;</span>
	}
	
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	protected boolean canEqual(final java.lang.Object other) {
<span class="nc" id="L623">		return other instanceof PircBotX;</span>
	}
	
	@java.lang.Override
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public int hashCode() {
<span class="fc" id="L630">		final int PRIME = 59;</span>
<span class="fc" id="L631">		int result = 1;</span>
<span class="fc" id="L632">		result = result * PRIME + this.getBotId();</span>
<span class="fc" id="L633">		return result;</span>
	}
	
	/**
	 * Unique number for this bot
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public int getBotId() {
<span class="fc" id="L642">		return this.botId;</span>
	}
	
	/**
	 * Configuration used for this bot
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public Configuration getConfiguration() {
<span class="fc" id="L651">		return this.configuration;</span>
	}
	
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public InputParser getInputParser() {
<span class="fc" id="L657">		return this.inputParser;</span>
	}
	
	/**
	 * User-Channel mapper
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public UserChannelDao&lt;User, Channel&gt; getUserChannelDao() {
<span class="fc" id="L666">		return this.userChannelDao;</span>
	}
	
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public DccHandler getDccHandler() {
<span class="fc" id="L672">		return this.dccHandler;</span>
	}
	
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	protected Socket getSocket() {
<span class="nc" id="L678">		return this.socket;</span>
	}
	
	/**
	 * Enabled CAP features
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public List&lt;String&gt; getEnabledCapabilities() {
<span class="fc" id="L687">		return this.enabledCapabilities;</span>
	}
	
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public String getServerHostname() {
<span class="fc" id="L693">		return this.serverHostname;</span>
	}
	
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public int getServerPort() {
<span class="fc" id="L699">		return this.serverPort;</span>
	}
	
	/**
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public boolean isNickservIdentified() {
<span class="fc" id="L707">		return this.nickservIdentified;</span>
	}
	
	/**
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	protected void setNickservIdentified(final boolean nickservIdentified) {
<span class="fc" id="L715">		this.nickservIdentified = nickservIdentified;</span>
<span class="fc" id="L716">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>